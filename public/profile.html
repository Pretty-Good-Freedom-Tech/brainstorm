<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr User Profile</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .profile-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .profile-sidebar {
            flex: 0 0 250px;
        }
        
        .profile-content {
            flex: 1;
            min-width: 300px;
        }
        
        .profile-picture {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 15px;
            border: 3px solid #3498db;
        }
        
        .profile-info {
            margin-bottom: 20px;
        }
        
        .profile-info h2 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .profile-info p {
            margin: 5px 0;
            line-height: 1.5;
        }
        
        .profile-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background-color: #f9f9f9;
            padding: 10px 15px;
            border-radius: 5px;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }
        
        .stat-box h3 {
            margin: 0;
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .stat-box p {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .profile-links {
            margin-top: 15px;
        }
        
        .profile-links a {
            display: inline-block;
            margin-right: 10px;
            color: #3498db;
            text-decoration: none;
        }
        
        .profile-links a:hover {
            text-decoration: underline;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            width: 100%;
        }
        
        .loading::after {
            content: "Loading profile...";
            font-size: 18px;
            color: #666;
        }
        
        .error-message {
            padding: 15px;
            background-color: #f8d7da;
            color: #721c24;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .nav-links {
            display: flex;
            gap: 10px;
        }
        
        .nav-links a {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .nav-links a:hover {
            background-color: #2980b9;
        }
        
        .profile-about {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            line-height: 1.6;
        }
        
        .profile-about h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .profile-about p {
            margin-bottom: 0;
        }
        
        .profile-about a {
            color: #3498db;
            text-decoration: none;
        }
        
        .profile-about a:hover {
            text-decoration: underline;
        }
        
        .profile-metadata {
            margin-top: 20px;
        }
        
        .profile-metadata h3 {
            margin-bottom: 10px;
        }
        
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .metadata-table th, .metadata-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .metadata-table th {
            background-color: #f2f2f2;
            font-weight: normal;
            width: 40%;
        }
        
        .metadata-table td {
            word-break: break-word;
        }
        
        .pubkey-display {
            font-family: monospace;
            word-break: break-all;
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 5px;
            font-size: 14px;
        }
        
        /* Network Visualization Styles */
        .network-visualization {
            margin-top: 30px;
            border: 1px solid #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .network-visualization h3 {
            margin: 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #eee;
        }
        
        .network-container {
            height: 500px;
            position: relative;
            background-color: #f9f9f9;
        }
        
        .network-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 10;
        }
        
        .network-loading::after {
            content: "Loading network data...";
            font-size: 18px;
            color: #666;
        }
        
        .network-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            z-index: 5;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 20;
            max-width: 250px;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Nostr User Profile</h1>
            <div class="nav-links">
                <a href="/control">Control Panel</a>
                <a href="/control/profiles">All Profiles</a>
            </div>
        </div>
        
        <div id="loadingIndicator" class="loading"></div>
        
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        
        <div id="profileContainer" class="profile-container" style="display: none;">
            <div class="profile-sidebar">
                <img id="profilePicture" class="profile-picture" src="/img/default-avatar.png" alt="Profile Picture">
                <div class="profile-info">
                    <h2 id="displayName">Loading...</h2>
                    <p id="username">@username</p>
                    <p id="nip05" style="display: none;"></p>
                    <div class="pubkey-display" id="pubkeyDisplay"></div>
                </div>
                <div class="profile-links" id="profileLinks">
                    <!-- Links will be added here -->
                </div>
            </div>
            
            <div class="profile-content">
                <div class="profile-stats">
                    <div class="stat-box">
                        <h3>PageRank</h3>
                        <p id="pageRankValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Hops</h3>
                        <p id="hopsValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Influence</h3>
                        <p id="influenceValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Confidence</h3>
                        <p id="confidenceValue">-</p>
                    </div>
                </div>
                
                <div class="profile-stats">
                    <div class="stat-box">
                        <h3>Following</h3>
                        <p id="followingCountValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Followers</h3>
                        <p id="followerCountValue">-</p>
                    </div>
                </div>
                
                <div class="profile-stats">
                    <div class="stat-box">
                        <h3>Muting</h3>
                        <p id="mutingCountValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Muters</h3>
                        <p id="muterCountValue">-</p>
                    </div>
                </div>
                
                <div class="profile-stats">
                    <div class="stat-box">
                        <h3>Reporting</h3>
                        <p id="reportingCountValue">-</p>
                    </div>
                    <div class="stat-box">
                        <h3>Reporters</h3>
                        <p id="reporterCountValue">-</p>
                    </div>
                </div>
                
                <div class="profile-about" id="aboutSection">
                    <h3>About</h3>
                    <p id="aboutText">No information available</p>
                </div>
                
                <div class="profile-metadata">
                    <h3>Profile Metadata</h3>
                    <table class="metadata-table" id="metadataTable">
                        <tbody>
                            <!-- Metadata will be added here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="network-visualization">
                    <h3>Network Proximity Visualization</h3>
                    <div id="networkContainer" class="network-container">
                        <div id="networkLoading" class="network-loading"></div>
                        <div id="networkLegend" class="network-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #3498db;"></div>
                                <span>Center (This User)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #2ecc71;"></div>
                                <span>Following</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #27ae60;"></div>
                                <span>Followers</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #f39c12;"></div>
                                <span>Muting</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #d35400;"></div>
                                <span>Muters</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #e74c3c;"></div>
                                <span>Reporting</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #c0392b;"></div>
                                <span>Reporters</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Include D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        // Get pubkey from URL
        const urlParams = new URLSearchParams(window.location.search);
        const pubkey = urlParams.get('pubkey');
        
        // Get DOM elements
        const profileContainer = document.getElementById('profileContainer');
        const errorMessage = document.getElementById('errorMessage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        // Determine the base URL for API calls
        const baseUrl = window.location.pathname.includes('/control/') ? '/control' : '';
        
        // Load profile data if pubkey is provided
        if (pubkey) {
            // Hide error message
            errorMessage.style.display = 'none';
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            profileContainer.style.display = 'none';
            
            // Set the pubkey in the display
            pubkeyDisplay.textContent = pubkey;
            
            // Sequential API calls to prevent concurrent request issues
            loadProfileDataSequentially(pubkey, baseUrl);
        } else {
            // Show error message if no pubkey is provided
            showError('No pubkey provided');
        }
        
        // Function to load profile data sequentially
        function loadProfileDataSequentially(pubkey, baseUrl) {
            // Step 1: Load Neo4j data
            fetch(`${baseUrl}/api/get-user-data?pubkey=${encodeURIComponent(pubkey)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayNeo4jData(data.data);
                        updateProfileStats(data.data);
                        
                        // Step 2: Only after Neo4j data is loaded, fetch kind 0 data
                        return fetch(`${baseUrl}/api/get-kind0?pubkey=${encodeURIComponent(pubkey)}`);
                    } else {
                        throw new Error(data.message || 'Failed to fetch Neo4j data');
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayKind0Data(data.data);
                        
                        // Show profile container
                        loadingIndicator.style.display = 'none';
                        profileContainer.style.display = 'flex';
                        
                        // Step 3: Only after kind 0 data is loaded, fetch network data
                        // Wait a short delay to ensure the previous request is fully complete
                        setTimeout(() => {
                            fetchAndDisplayNetworkData(pubkey, baseUrl);
                        }, 500);
                    } else {
                        // If we can't get kind 0 data, still show what we have
                        console.warn('Could not fetch kind 0 data:', data.message);
                        
                        // Show profile container
                        loadingIndicator.style.display = 'none';
                        profileContainer.style.display = 'flex';
                        
                        // Step 3: Fetch network data with a delay
                        setTimeout(() => {
                            fetchAndDisplayNetworkData(pubkey, baseUrl);
                        }, 500);
                    }
                })
                .catch(error => {
                    console.error('Error fetching profile data:', error);
                    showError(`Error fetching profile data: ${error.message}`);
                });
        }
        
        // Function to display Neo4j data
        function displayNeo4jData(data) {
            // Update the profile stats with Neo4j data
            if (data.personalizedPageRank !== null && data.personalizedPageRank !== undefined) {
                pageRankValue.textContent = parseFloat(data.personalizedPageRank).toFixed(4);
            }
            
            if (data.hops !== null && data.hops !== undefined) {
                hopsValue.textContent = data.hops;
            }
            
            if (data.influence !== null && data.influence !== undefined) {
                influenceValue.textContent = parseFloat(data.influence).toFixed(4);
            }
            
            if (data.confidence !== null && data.confidence !== undefined) {
                confidenceValue.textContent = parseFloat(data.confidence).toFixed(4);
            }
            
            if (data.followingCount !== null && data.followingCount !== undefined) {
                followingCountValue.textContent = data.followingCount;
            }
            
            if (data.followerCount !== null && data.followerCount !== undefined) {
                followerCountValue.textContent = data.followerCount;
            }
            
            if (data.mutingCount !== null && data.mutingCount !== undefined) {
                mutingCountValue.textContent = data.mutingCount;
            }
            
            if (data.muterCount !== null && data.muterCount !== undefined) {
                muterCountValue.textContent = data.muterCount;
            }
            
            if (data.reportingCount !== null && data.reportingCount !== undefined) {
                reportingCountValue.textContent = data.reportingCount;
            }
            
            if (data.reporterCount !== null && data.reporterCount !== undefined) {
                reporterCountValue.textContent = data.reporterCount;
            }
        }
        
        // Function to display kind 0 data
        function displayKind0Data(data) {
            if (!data || !data.content) {
                return;
            }
            
            try {
                // Parse the content as JSON
                const profileContent = JSON.parse(data.content);
                
                // Update display name
                if (profileContent.name) {
                    displayName.textContent = profileContent.name;
                    document.title = `${profileContent.name} - Nostr Profile`;
                }
                
                // Update username/nickname
                if (profileContent.display_name || profileContent.displayName) {
                    const nick = profileContent.display_name || profileContent.displayName;
                    username.textContent = nick;
                } else if (profileContent.name) {
                    username.textContent = `@${profileContent.name.toLowerCase().replace(/\s+/g, '_')}`;
                }
                
                // Update profile picture
                if (profileContent.picture) {
                    profilePicture.src = profileContent.picture;
                    profilePicture.onerror = () => {
                        profilePicture.src = '/img/default-avatar.png';
                    };
                }
                
                // Update NIP-05 identifier
                if (profileContent.nip05) {
                    nip05.textContent = `✓ ${profileContent.nip05}`;
                    nip05.style.display = 'block';
                }
                
                // Update about text
                if (profileContent.about) {
                    aboutText.textContent = profileContent.about;
                    
                    // Convert URLs to links
                    aboutText.innerHTML = aboutText.innerHTML.replace(
                        /(https?:\/\/[^\s]+)/g, 
                        '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
                    );
                }
                
                // Add website link if available
                if (profileContent.website) {
                    addProfileLink('Website', profileContent.website);
                }
                
                // Add social media links
                const socialPlatforms = {
                    twitter: { label: 'Twitter', url: 'https://twitter.com/' },
                    github: { label: 'GitHub', url: 'https://github.com/' },
                    instagram: { label: 'Instagram', url: 'https://instagram.com/' },
                    linkedin: { label: 'LinkedIn', url: 'https://linkedin.com/in/' }
                };
                
                for (const [platform, info] of Object.entries(socialPlatforms)) {
                    if (profileContent[platform]) {
                        const username = profileContent[platform].replace('@', '');
                        addProfileLink(info.label, `${info.url}${username}`);
                    }
                }
                
                // Add all metadata to the table
                metadataTable.innerHTML = '';
                for (const [key, value] of Object.entries(profileContent)) {
                    if (value && typeof value === 'string') {
                        addMetadataRow(key, value);
                    }
                }
                
                // Add event metadata
                if (data.created_at) {
                    const date = new Date(data.created_at * 1000);
                    addMetadataRow('Profile Updated', date.toLocaleString());
                }
                
                if (data.id) {
                    addMetadataRow('Event ID', data.id);
                }
            } catch (error) {
                console.error('Error parsing profile content:', error);
            }
        }
        
        // Function to update profile stats
        function updateProfileStats(userData) {
            // Update the profile stats with Neo4j data
            if (userData.personalizedPageRank !== null && userData.personalizedPageRank !== undefined) {
                pageRankValue.textContent = parseFloat(userData.personalizedPageRank).toFixed(4);
            }
            
            if (userData.hops !== null && userData.hops !== undefined) {
                hopsValue.textContent = userData.hops;
            }
            
            if (userData.influence !== null && userData.influence !== undefined) {
                influenceValue.textContent = parseFloat(userData.influence).toFixed(4);
            }
            
            if (userData.confidence !== null && userData.confidence !== undefined) {
                confidenceValue.textContent = parseFloat(userData.confidence).toFixed(4);
            }
            
            if (userData.followingCount !== null && userData.followingCount !== undefined) {
                followingCountValue.textContent = userData.followingCount;
            }
            
            if (userData.followerCount !== null && userData.followerCount !== undefined) {
                followerCountValue.textContent = userData.followerCount;
            }
            
            if (userData.mutingCount !== null && userData.mutingCount !== undefined) {
                mutingCountValue.textContent = userData.mutingCount;
            }
            
            if (userData.muterCount !== null && userData.muterCount !== undefined) {
                muterCountValue.textContent = userData.muterCount;
            }
            
            if (userData.reportingCount !== null && userData.reportingCount !== undefined) {
                reportingCountValue.textContent = userData.reportingCount;
            }
            
            if (userData.reporterCount !== null && userData.reporterCount !== undefined) {
                reporterCountValue.textContent = userData.reporterCount;
            }
        }
        
        // Function to add profile link
        function addProfileLink(label, url) {
            const link = document.createElement('a');
            link.href = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = label;
            profileLinks.appendChild(link);
        }
        
        // Function to add metadata row
        function addMetadataRow(key, value) {
            const row = document.createElement('tr');
            
            const keyCell = document.createElement('th');
            keyCell.textContent = key.replace(/([A-Z])/g, ' $1')
                .replace(/_/g, ' ')
                .replace(/^./, str => str.toUpperCase());
            
            const valueCell = document.createElement('td');
            
            // Check if value is a URL
            if (value.match(/^https?:\/\//)) {
                const link = document.createElement('a');
                link.href = value;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.textContent = value;
                valueCell.appendChild(link);
            } else {
                valueCell.textContent = value;
            }
            
            row.appendChild(keyCell);
            row.appendChild(valueCell);
            metadataTable.appendChild(row);
        }
        
        // Function to show error message
        function showError(message) {
            loadingIndicator.style.display = 'none';
            profileContainer.style.display = 'none';
            errorMessage.style.display = 'block';
            errorMessage.textContent = message;
        }
        
        // Function to fetch and display network data
        function fetchAndDisplayNetworkData(pubkey, baseUrl) {
            // Show network loading state
            const networkLoading = document.getElementById('networkLoading');
            if (networkLoading) {
                networkLoading.style.display = 'flex';
            }
            
            // Use the absolute URL that we know works directly in the browser
            const apiUrl = `${window.location.origin}/control/api/get-network-proximity?pubkey=${encodeURIComponent(pubkey)}&limit=50`;
            console.log('Fetching network data from:', apiUrl);
            
            // Create a new XMLHttpRequest with timeout
            const xhr = new XMLHttpRequest();
            xhr.open('GET', apiUrl, true);
            xhr.timeout = 30000; // 30 second timeout
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.setRequestHeader('Cache-Control', 'no-cache');
            
            xhr.onload = function() {
                console.log('XHR status:', xhr.status);
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const data = JSON.parse(xhr.responseText);
                        console.log('Network data received:', data);
                        if (data.success) {
                            renderNetworkVisualization(data.data);
                        } else {
                            console.error('Failed to fetch network data:', data.message);
                            document.getElementById('networkContainer').innerHTML = 
                                `<div class="error-message">Failed to load network data: ${data.message}</div>`;
                        }
                    } catch (e) {
                        console.error('Error parsing JSON response:', e);
                        document.getElementById('networkContainer').innerHTML = 
                            `<div class="error-message">Error parsing network data: ${e.message}</div>`;
                    }
                } else {
                    console.error('XHR error:', xhr.status, xhr.statusText);
                    document.getElementById('networkContainer').innerHTML = 
                        `<div class="error-message">Error loading network data: ${xhr.status} ${xhr.statusText}</div>`;
                }
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            xhr.ontimeout = function() {
                console.error('Network request timed out');
                document.getElementById('networkContainer').innerHTML = 
                    '<div class="error-message">Network request timed out. The server might be busy processing the request.</div>';
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            xhr.onerror = function() {
                console.error('Network request failed');
                document.getElementById('networkContainer').innerHTML = 
                    '<div class="error-message">Network request failed. Please check your connection and try again.</div>';
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            // Send the request
            xhr.send();
        }
        
        // Function to render network visualization
        function renderNetworkVisualization(data) {
            try {
                // Check if we have valid data
                if (!data || !data.nodes || !data.links || data.nodes.length === 0) {
                    document.getElementById('networkContainer').innerHTML = 
                        '<div class="error-message">No network data available for this user.</div>';
                    return;
                }
                
                // Log data for debugging
                console.log('Rendering network with nodes:', data.nodes.length, 'links:', data.links.length);
                
                // Ensure all nodes have an id property
                data.nodes.forEach((node, index) => {
                    if (!node.id) {
                        console.warn('Node missing id, adding one:', node);
                        node.id = node.pubkey || `node_${index}`;
                    }
                    
                    // Initialize profilePicture property
                    node.profilePicture = null;
                    
                    // Set a minimum influence value to avoid tiny nodes
                    if (!node.influence || node.influence < 0.0001) {
                        node.influence = 0.0001;
                    }
                });
                
                // Define link colors based on relationship type
                const linkColors = {
                    'following': '#2ecc71',
                    'followers': '#27ae60',
                    'muting': '#f39c12',
                    'muters': '#d35400',
                    'reporting': '#e74c3c',
                    'reporters': '#c0392b'
                };
                
                // Fix data format issues - ensure nodes have unique IDs and links reference them correctly
                const nodesById = {};
                
                // Create a map of nodes by ID for quick lookup
                data.nodes.forEach(node => {
                    nodesById[node.id] = node;
                });
                
                // Filter out any links that reference non-existent nodes
                const validLinks = data.links.filter(link => {
                    // Check if source exists
                    let sourceExists = false;
                    if (typeof link.source === 'string') {
                        sourceExists = nodesById[link.source] !== undefined;
                    } else if (link.source && link.source.id) {
                        sourceExists = nodesById[link.source.id] !== undefined;
                    }
                    
                    // Check if target exists
                    let targetExists = false;
                    if (typeof link.target === 'string') {
                        targetExists = nodesById[link.target] !== undefined;
                    } else if (link.target && link.target.id) {
                        targetExists = nodesById[link.target.id] !== undefined;
                    }
                    
                    return sourceExists && targetExists;
                });
                
                // Convert any object references to string IDs for consistency
                validLinks.forEach(link => {
                    if (typeof link.source !== 'string' && link.source && link.source.id) {
                        link.source = link.source.id;
                    }
                    if (typeof link.target !== 'string' && link.target && link.target.id) {
                        link.target = link.target.id;
                    }
                });
                
                // Clear any existing visualization
                d3.select('#networkContainer svg').remove();
                d3.select('#networkContainer .tooltip').remove();
                
                // Show loading indicator while fetching profile pictures
                document.getElementById('networkContainer').innerHTML = 
                    '<div class="loading-indicator">Loading profile pictures...</div>';
                
                // Fetch profile pictures for all nodes
                const fetchProfilePictures = async () => {
                    const promises = data.nodes.map(async (node) => {
                        try {
                            // Skip if this is not a valid pubkey
                            if (!node.id || node.id.length < 32) return;
                            
                            const apiUrl = `${window.location.origin}/control/api/get-kind0?pubkey=${encodeURIComponent(node.id)}`;
                            console.log(`Fetching profile for ${node.id} from ${apiUrl}`);
                            
                            const response = await fetch(apiUrl);
                            
                            // Check if response is OK and has the correct content type
                            if (!response.ok) {
                                console.warn(`Error fetching profile for ${node.id}: HTTP ${response.status}`);
                                return;
                            }
                            
                            const contentType = response.headers.get('content-type');
                            if (!contentType || !contentType.includes('application/json')) {
                                console.warn(`Invalid content type for ${node.id}: ${contentType}`);
                                return;
                            }
                            
                            const kind0Data = await response.json();
                            
                            if (kind0Data.success && kind0Data.data && kind0Data.data.content) {
                                try {
                                    const content = JSON.parse(kind0Data.data.content);
                                    if (content.picture) {
                                        node.profilePicture = content.picture;
                                        node.name = content.name || content.display_name || node.id.substring(0, 8);
                                        console.log(`Found profile picture for ${node.id}: ${node.profilePicture}`);
                                    }
                                } catch (e) {
                                    console.warn('Error parsing kind0 content for', node.id, e);
                                }
                            }
                        } catch (error) {
                            console.warn('Error fetching profile for', node.id, error);
                        }
                    });
                    
                    // Wait for all profile picture fetches to complete
                    await Promise.allSettled(promises);
                    console.log('All profile pictures fetched, nodes with pictures:', 
                        data.nodes.filter(n => n.profilePicture).length);
                    
                    // Now render the visualization with profile pictures
                    renderVisualization();
                };
                
                // Start fetching profile pictures
                fetchProfilePictures();
                
                // Declare simulation at a higher scope so it's accessible to drag functions
                let simulation;
                
                // Function to render the visualization after profile pictures are loaded
                function renderVisualization() {
                    // Clear loading indicator
                    document.getElementById('networkContainer').innerHTML = '';
                    
                    // Set up dimensions
                    const container = document.getElementById('networkContainer');
                    const width = container.clientWidth || 600;
                    const height = container.clientHeight || 400;
                    
                    // Define color scale for node types
                    const nodeColors = {
                        'center': '#3498db',
                        'following': '#2ecc71',
                        'followers': '#27ae60',
                        'muting': '#f39c12',
                        'muters': '#d35400',
                        'reporting': '#e74c3c',
                        'reporters': '#c0392b'
                    };
                    
                    // Create SVG container
                    const svg = d3.select('#networkContainer')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height);
                    
                    // Add arrow markers for directional links
                    svg.append("defs").selectAll("marker")
                        .data(["following", "followers", "muting", "muters", "reporting", "reporters"])
                        .enter().append("marker")
                        .attr("id", d => `arrow-${d}`)
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 25)  // Position the arrow away from the node
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", d => linkColors[d] || "#999");
                    
                    // Add defs for profile picture patterns
                    const defs = svg.append("defs");
                    
                    // Create patterns for each node with a profile picture
                    data.nodes.forEach(node => {
                        if (node.profilePicture) {
                            console.log(`Creating pattern for ${node.id} with image ${node.profilePicture}`);
                            
                            // Create a pattern with a unique ID
                            const patternId = `profile-pic-${node.id.replace(/[^a-zA-Z0-9]/g, '-')}`;
                            
                            // Create a pattern for the profile picture
                            const pattern = defs.append("pattern")
                                .attr("id", patternId)
                                .attr("patternUnits", "objectBoundingBox")
                                .attr("width", 1)
                                .attr("height", 1);
                            
                            // Add a white background circle to ensure the image is visible
                            pattern.append("circle")
                                .attr("cx", 0.5)
                                .attr("cy", 0.5)
                                .attr("r", 0.5)
                                .attr("fill", "white");
                            
                            // Add the image to the pattern
                            pattern.append("image")
                                .attr("xlink:href", node.profilePicture)
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("width", 1)
                                .attr("height", 1)
                                .attr("preserveAspectRatio", "xMidYMid slice");
                            
                            // Store the pattern ID in the node for reference
                            node.patternId = patternId;
                        }
                    });
                    
                    // Create tooltip
                    const tooltip = d3.select('#networkContainer')
                        .append('div')
                        .attr('class', 'tooltip')
                        .style('opacity', 0)
                        .style('position', 'absolute')
                        .style('background-color', 'white')
                        .style('border', '1px solid #ddd')
                        .style('border-radius', '4px')
                        .style('padding', '8px')
                        .style('pointer-events', 'none')
                        .style('font-size', '12px')
                        .style('z-index', '10')
                        .style('max-width', '300px');
                    
                    // Calculate node radius based on influence
                    const influenceScale = d3.scaleSqrt()
                        .domain([
                            d3.min(data.nodes, d => d.influence || 0.0001),
                            d3.max(data.nodes, d => d.influence || 1)
                        ])
                        .range([5, 25]);  // Min and max radius
                    
                    // Create force simulation
                    simulation = d3.forceSimulation(data.nodes)
                        .force('link', d3.forceLink(validLinks)
                            .id(d => d.id)
                            .distance(d => {
                                // Make distance dependent on node sizes
                                const sourceNode = nodesById[d.source.id || d.source];
                                const targetNode = nodesById[d.target.id || d.target];
                                const sourceRadius = influenceScale(sourceNode.influence || 0.0001);
                                const targetRadius = influenceScale(targetNode.influence || 0.0001);
                                return 100 + sourceRadius + targetRadius;
                            }))
                        .force('charge', d3.forceManyBody().strength(-300))
                        .force('center', d3.forceCenter(width / 2, height / 2))
                        .force('collision', d3.forceCollide().radius(d => influenceScale(d.influence || 0.0001) + 5));
                    
                    // Create links as paths for directional arrows
                    const link = svg.append('g')
                        .selectAll('path')
                        .data(validLinks)
                        .enter()
                        .append('path')
                        .attr('stroke', d => linkColors[d.type] || '#999')
                        .attr('stroke-opacity', 0.6)
                        .attr('stroke-width', 2)
                        .attr('fill', 'none')
                        .attr('marker-end', d => `url(#arrow-${d.type})`);
                    
                    // Create node groups
                    const nodeGroup = svg.append('g')
                        .selectAll('g')
                        .data(data.nodes)
                        .enter()
                        .append('g')
                        .call(d3.drag()
                            .on('start', dragstarted)
                            .on('drag', dragged)
                            .on('end', dragended));
                    
                    // Add circle for each node
                    const node = nodeGroup.append('circle')
                        .attr('r', d => influenceScale(d.influence || 0.0001))
                        .attr('fill', d => {
                            // Use profile picture if available, otherwise use color
                            if (d.patternId) {
                                return `url(#${d.patternId})`;
                            }
                            return nodeColors[d.type] || '#999';
                        })
                        .attr('stroke', d => nodeColors[d.type] || '#999')
                        .attr('stroke-width', 2);
                    
                    // Add node labels
                    const labels = nodeGroup.append('text')
                        .text(d => {
                            // Show short name for center node, nothing for others to avoid clutter
                            if (d.type === 'center') {
                                return d.name || d.id.substring(0, 6) + '...';
                            }
                            return '';
                        })
                        .attr('font-size', '10px')
                        .attr('dx', d => influenceScale(d.influence || 0.0001) + 5)
                        .attr('dy', 4)
                        .attr('fill', '#333');
                    
                    // Add hover effects and tooltips
                    nodeGroup.on('mouseover', function(event, d) {
                            // Highlight connected links and nodes
                            link.style('stroke-opacity', l => {
                                // Check if the link is connected to this node
                                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                                return sourceId === d.id || targetId === d.id ? 1 : 0.1;
                            });
                            
                            nodeGroup.style('opacity', n => {
                                // Check if this node is connected to the hovered node
                                if (n.id === d.id) return 1;
                                
                                // Check if there's a link between these nodes
                                const connected = validLinks.some(l => {
                                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                                    return (sourceId === d.id && targetId === n.id) || 
                                           (sourceId === n.id && targetId === d.id);
                                });
                                
                                return connected ? 1 : 0.3;
                            });
                            
                            // Show tooltip
                            tooltip.transition()
                                .duration(200)
                                .style('opacity', .9);
                            
                            // Format tooltip content with detailed web of trust scores
                            let tooltipContent = `
                                <div style="text-align: center; margin-bottom: 8px;">
                                    ${d.profilePicture ? `<img src="${d.profilePicture}" style="width: 50px; height: 50px; border-radius: 25px; margin-bottom: 5px;">` : ''}
                                    <strong>${d.name || (d.id || '').substring(0, 10) + '...'}</strong>
                                </div>
                                <div style="font-size: 11px; color: #666;">Pubkey: ${(d.id || '').substring(0, 10)}...</div>
                                <hr style="margin: 5px 0; border-top: 1px solid #eee;">
                                <div><strong>Web of Trust Scores:</strong></div>
                                <div>Hops: ${d.hops !== undefined && d.hops !== null ? d.hops : 'N/A'}</div>
                                <div>Influence: ${d.influence !== undefined && d.influence !== null ? parseFloat(d.influence).toFixed(6) : 'N/A'}</div>
                                <div>PageRank: ${d.personalizedPageRank !== undefined && d.personalizedPageRank !== null ? parseFloat(d.personalizedPageRank).toFixed(6) : 'N/A'}</div>
                                <div>Relationship: ${d.type || 'N/A'}</div>
                            `;
                            
                            tooltip.html(tooltipContent)
                                .style('left', (event.pageX + 10) + 'px')
                                .style('top', (event.pageY - 28) + 'px');
                        })
                        .on('mouseout', function() {
                            // Reset link and node opacity
                            link.style('stroke-opacity', 0.6);
                            nodeGroup.style('opacity', 1);
                            
                            // Hide tooltip
                            tooltip.transition()
                                .duration(500)
                                .style('opacity', 0);
                        });
                    
                    // Add simulation tick handler
                    simulation.on('tick', () => {
                        // Update link paths for curved directional links
                        link.attr('d', d => {
                            // Get source and target nodes
                            const source = typeof d.source === 'object' ? d.source : nodesById[d.source];
                            const target = typeof d.target === 'object' ? d.target : nodesById[d.target];
                            
                            // Safety check for valid coordinates
                            if (!source || !target || 
                                typeof source.x !== 'number' || typeof source.y !== 'number' ||
                                typeof target.x !== 'number' || typeof target.y !== 'number' ||
                                isNaN(source.x) || isNaN(source.y) || 
                                isNaN(target.x) || isNaN(target.y)) {
                                return ''; // Return empty path if coordinates are invalid
                            }
                            
                            // Calculate path for directional arrow
                            const dx = target.x - source.x;
                            const dy = target.y - source.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            
                            // Safety check for zero length
                            if (length === 0) {
                                return ''; // Return empty path if length is zero
                            }
                            
                            // Calculate the normalized direction vector
                            const normX = dx / length;
                            const normY = dy / length;
                            
                            // Get node radii
                            const sourceRadius = influenceScale(source.influence || 0.0001);
                            const targetRadius = influenceScale(target.influence || 0.0001);
                            
                            // Calculate start and end points, offset by node radius
                            const startX = source.x + (sourceRadius * normX);
                            const startY = source.y + (sourceRadius * normY);
                            const endX = target.x - (targetRadius * normX);
                            const endY = target.y - (targetRadius * normY);
                            
                            // Safety check for valid path points
                            if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
                                return ''; // Return empty path if any coordinate is NaN
                            }
                            
                            // Return a straight line instead of a curve to avoid arc calculation issues
                            return `M${startX},${startY}L${endX},${endY}`;
                        });
                        
                        // Update node group positions
                        nodeGroup.attr('transform', d => {
                            // Safety check for valid coordinates
                            if (typeof d.x !== 'number' || typeof d.y !== 'number' || isNaN(d.x) || isNaN(d.y)) {
                                d.x = width / 2;
                                d.y = height / 2;
                            }
                            
                            // Keep nodes within bounds
                            const radius = influenceScale(d.influence || 0.0001);
                            d.x = Math.max(radius, Math.min(width - radius, d.x));
                            d.y = Math.max(radius, Math.min(height - radius, d.y));
                            
                            return `translate(${d.x}, ${d.y})`;
                        });
                    });
                    
                    // Add a legend for relationship types
                    const legend = svg.append('g')
                        .attr('class', 'legend')
                        .attr('transform', 'translate(20, 20)');
                    
                    const legendItems = [
                        { type: 'center', label: 'Center User' },
                        { type: 'following', label: 'Following' },
                        { type: 'followers', label: 'Followers' },
                        { type: 'muting', label: 'Muting' },
                        { type: 'muters', label: 'Muters' },
                        { type: 'reporting', label: 'Reporting' },
                        { type: 'reporters', label: 'Reporters' }
                    ];
                    
                    legendItems.forEach((item, i) => {
                        const legendItem = legend.append('g')
                            .attr('transform', `translate(0, ${i * 20})`);
                        
                        legendItem.append('circle')
                            .attr('r', 6)
                            .attr('fill', nodeColors[item.type] || '#999');
                        
                        legendItem.append('text')
                            .attr('x', 15)
                            .attr('y', 4)
                            .text(item.label)
                            .attr('font-size', '12px');
                    });
                    
                    // Add an influence scale legend
                    const influenceLegend = svg.append('g')
                        .attr('class', 'influence-legend')
                        .attr('transform', `translate(${width - 150}, 20)`);
                    
                    influenceLegend.append('text')
                        .attr('x', 0)
                        .attr('y', 0)
                        .text('Influence Scale:')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold');
                    
                    // Show 3 example sizes
                    const influenceExamples = [
                        { label: 'Low', value: d3.min(data.nodes, d => d.influence || 0.0001) },
                        { label: 'Medium', value: (d3.min(data.nodes, d => d.influence || 0.0001) + d3.max(data.nodes, d => d.influence || 1)) / 2 },
                        { label: 'High', value: d3.max(data.nodes, d => d.influence || 1) }
                    ];
                    
                    influenceExamples.forEach((example, i) => {
                        const exampleItem = influenceLegend.append('g')
                            .attr('transform', `translate(30, ${i * 30 + 20})`);
                        
                        exampleItem.append('circle')
                            .attr('r', influenceScale(example.value))
                            .attr('fill', '#999')
                            .attr('opacity', 0.5);
                        
                        exampleItem.append('text')
                            .attr('x', 35)
                            .attr('y', 4)
                            .text(`${example.label}: ${example.value.toFixed(6)}`)
                            .attr('font-size', '10px');
                    });
                }
                
                // Drag functions
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
            } catch (error) {
                console.error('Error rendering network visualization:', error);
                document.getElementById('networkContainer').innerHTML = 
                    `<div class="error-message">Error rendering network visualization: ${error.message}</div>`;
            }
        }
    </script>
</body>
</html>
