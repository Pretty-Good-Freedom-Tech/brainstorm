<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainstorm</title>
    <link rel="stylesheet" href="/css/search.css">
    <link rel="shortcut icon" href="/img/brainstorm010.svg">
    <script src="./components/header/header.js"></script>
    <script src="./components/footer/footer.js"></script>
    <script src="/components/observerSelector/observerSelector.js"></script>
</head>
<body>
    <!-- Include the header component -->
    <div id="headerContainer"></div>

    <!-- Main content wrapper -->
    <div class="page-content">
        <div class="container">
            <div class="search-controls">
                <div class="search-input-wrapper">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search profiles by name, display name, about, etc. (Press Enter to search)">
                </div>
                <div class="toggle-wrapper">
                    <label class="toggle-container">
                        <input type="checkbox" id="verifiedOnlyToggle" checked>
                        <span class="toggle-slider"></span>
                        <span class="toggle-label">Show verified only</span>
                    </label>
                </div>
            </div>
            
            <!-- Observer Selector -->
            <div id="observerSelectorContainer"></div>
            
            <br />
            <div id="searchResults" class="search-results"  style="display: none;">
                <!-- Search results will be dynamically added here -->
            </div>

            <hr />

            <div id="profileCard" class="profile-card"  style="display: none;">
                <!-- Profile card will be dynamically added here
                 will contain profile information includig picture, displayName, username, about, and will link to profile page -->
            </div>
        </div>
    </div>

    <!-- Include the footer component -->
    <div id="footerContainer"></div>

    <script>
        // Get DOM element references
        const searchResults = document.getElementById('searchResults');
        const searchInput = document.getElementById('searchInput');
        const verifiedOnlyToggle = document.getElementById('verifiedOnlyToggle');
        
        // Observer selector and state management
        let observerSelector;
        let currentObserverPubkey = 'owner'; // Default to global/owner view
        
        // Main search function
        function performSearch() {
            const searchValue = searchInput.value.trim();
            
            // Don't search if input is empty or too short
            if (searchValue.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchResults.innerHTML = '';
            
            // Show loading message
            searchResults.innerHTML = '<div class="loading-message">Searching profiles...</div>';
            searchResults.style.display = 'block';
            
            // Send a GET request to the API endpoint
            const searchUrl = `/api/search/profiles?searchType=kind0&searchString=${encodeURIComponent(searchValue)}`;
            const urlWithObserver = currentObserverPubkey !== 'owner' ? `${searchUrl}&observerPubkey=${encodeURIComponent(currentObserverPubkey)}` : searchUrl;
            fetch(urlWithObserver)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.pubkeys && data.pubkeys.length > 0) {
                        // Clear loading message
                        searchResults.innerHTML = '';
                        
                        // Create profile panels for each pubkey
                        createProfilePanels(data.pubkeys, searchResults);
                    } else {
                        searchResults.innerHTML = '<div class="no-results">No profiles found matching your search criteria.</div>';
                        console.error('Search failed:', data.error);
                    }
                })
                .catch(error => {
                    searchResults.innerHTML = '<div class="error-message">Error during search. Please try again.</div>';
                    console.error('Error during search:', error);
                });
        }
        
        // Enter key event listener for immediate search
        searchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                performSearch();
            }
        });
        
        // Toggle event listener for verified-only filter
        verifiedOnlyToggle.addEventListener('change', () => {
            // Re-filter existing results if any are displayed
            if (searchResults.style.display !== 'none' && searchResults.children.length > 0) {
                filterDisplayedProfiles();
            }
        });
        
        // Function to filter displayed profiles based on verified-only toggle
        function filterDisplayedProfiles() {
            const showVerifiedOnly = verifiedOnlyToggle.checked;
            const profileCards = searchResults.querySelectorAll('.profile-card');
            
            profileCards.forEach(card => {
                const influenceScore = parseFloat(card.dataset.influence) || 0;
                
                if (showVerifiedOnly && influenceScore < 0.01) {
                    card.style.display = 'none';
                } else {
                    card.style.display = 'block';
                }
            });
            
            // Check if any profiles are visible after filtering
            const visibleProfiles = Array.from(profileCards).filter(card => card.style.display !== 'none');
            if (visibleProfiles.length === 0 && profileCards.length > 0) {
                searchResults.innerHTML = '<div class="no-results">No verified profiles found matching your search criteria.</div>';
            }
        }
        
        // Function to create profile panels for multiple pubkeys
        async function createProfilePanels(pubkeys, container) {
            const profileData = [];
            
            // Process pubkeys in batches to avoid overwhelming the API
            const batchSize = 5;
            for (let i = 0; i < pubkeys.length; i += batchSize) {
                const batch = pubkeys.slice(i, i + batchSize);
                const batchPromises = batch.map(pubkey => createSingleProfilePanel(pubkey));
                
                try {
                    const batchResults = await Promise.all(batchPromises);
                    profileData.push(...batchResults.filter(data => data !== null));
                    
                    // Sort profiles by influence score (descending)
                    const sortedProfiles = profileData.sort((a, b) => {
                        const influenceA = a.influence || 0;
                        const influenceB = b.influence || 0;
                        return influenceB - influenceA; // Descending order
                    });
                    
                    // Display sorted profiles
                    container.innerHTML = sortedProfiles.map(data => data.html).join('');
                    
                    // Apply verified-only filter if enabled
                    filterDisplayedProfiles();
                    
                    // Add a small delay between batches to be respectful to the API
                    if (i + batchSize < pubkeys.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error('Error processing batch:', error);
                }
            }
            
            // Final update
            if (profileData.length === 0) {
                container.innerHTML = '<div class="no-results">No profile data could be retrieved for the found pubkeys.</div>';
            }
        }
        
        // Function to create a single profile panel
        async function createSingleProfilePanel(pubkey) {
            try {
                // Fetch both profile data and trust score data in parallel
                const trustUrl = `/api/get-profile-scores?pubkey=${pubkey}`;
                const trustUrlWithObserver = currentObserverPubkey !== 'owner' ? `${trustUrl}&observerPubkey=${encodeURIComponent(currentObserverPubkey)}` : trustUrl;
                
                const [profileResponse, trustResponse] = await Promise.all([
                    fetch(`/api/get-kind0?pubkey=${pubkey}`),
                    fetch(trustUrlWithObserver)
                ]);
                
                const profileResult = await profileResponse.json();
                const trustResult = await trustResponse.json();
                
                if (profileResult.success && profileResult.data) {
                    // Parse the kind 0 event content
                    const event = profileResult.data;
                    const content = JSON.parse(event.content);
                    
                    // Extract profile details
                    const picture = content.picture || '/control/img/default-avatar.svg';
                    const name = content.name || 'Unknown';
                    const displayName = content.display_name || content.displayName || name;
                    const about = content.about || '';
                    
                    // Create npub for display (truncated)
                    const npubDisplay = pubkey.length > 12 ? `${pubkey.substring(0, 8)}...${pubkey.substring(pubkey.length - 4)}` : pubkey;
                    
                    // Store trust score data in cache if available
                    if (trustResult.success && trustResult.data) {
                        const trustData = {
                            hops: trustResult.data.profileData.hops,
                            influence: trustResult.data.profileData.influence,
                            personalizedPageRank: trustResult.data.profileData.personalizedPageRank,
                            verifiedFollowerCount: trustResult.data.profileData.verifiedFollowerCount,
                            verifiedMuterCount: trustResult.data.profileData.verifiedMuterCount,
                            verifiedReporterCount: trustResult.data.profileData.verifiedReporterCount,
                            followerInput: trustResult.data.profileData.followerInput,
                            muterInput: trustResult.data.profileData.muterInput,
                            reporterInput: trustResult.data.profileData.reporterInput
                        };
                        trustScoreCache.set(pubkey, trustData);
                    } else {
                        // Store null to indicate trust data is not available
                        trustScoreCache.set(pubkey, null);
                    }
                    
                    // Extract influence score for sorting (default to 0 if not available)
                    let influenceScore = 0;
                    if (trustResult.success && trustResult.data && trustResult.data.profileData.influence !== undefined) {
                        influenceScore = parseFloat(trustResult.data.profileData.influence) || 0;
                    }
                    
                    // Extract verifiedReporterCount and verifiedFollowerCount for report visual cues
                    let verifiedReporterCount = 0;
                    let verifiedFollowerCount = 0;
                    let reporterInput = 0;
                    let followerInput = 0;
                    if (trustResult.success && trustResult.data) {
                        verifiedReporterCount = parseInt(trustResult.data.profileData.verifiedReporterCount) || 0;
                        verifiedFollowerCount = parseInt(trustResult.data.profileData.verifiedFollowerCount) || 0;
                        reporterInput = parseFloat(trustResult.data.profileData.reporterInput) || 0;
                        followerInput = parseFloat(trustResult.data.profileData.followerInput) || 0;
                    }
                    
                    // Calculate effectiveReporterInput with follower correction factor
                    const correctionFactor = Math.round((followerInput / 500) * 10) / 10; // Round to 1 decimal place
                    const effectiveReporterInput = Math.max(0, reporterInput - correctionFactor);
                    
                    // Determine visual trust cues based on influence score
                    const isVerified = influenceScore > 0.1;
                    const isLowInfluence = influenceScore < 1.0;
                    const opacityValue = Math.max(0.1, influenceScore); // Minimum 0.1 opacity for visibility
                    
                    // Determine visual report cues based on effectiveReporterInput
                    const isReported = effectiveReporterInput > 0;
                    const borderThickness = Math.min(2 + (effectiveReporterInput * 2), 10); // 2px base + 2px per effective report, max 10px
                    
                    // Build CSS classes for visual cues
                    let cssClasses = 'profile-card';
                    if (isVerified) {
                        cssClasses += ' verified';
                    }
                    if (isLowInfluence) {
                        cssClasses += ' low-influence';
                    }
                    if (isReported) {
                        cssClasses += ' reported';
                    }
                    
                    // Build dynamic styles for reported profiles
                    let dynamicStyles = `opacity: ${opacityValue};`;
                    if (isReported) {
                        dynamicStyles += ` border-width: ${borderThickness}px; border-style: solid;`;
                    }

                    let verifiedReporterCountText = '';

                    if (effectiveReporterInput > 0 && verifiedReporterCount > 0 ) {
                        if (verifiedReporterCount == 1) {
                            verifiedReporterCountText = `${verifiedReporterCount} 🍇 reporter`;
                        } else {
                            verifiedReporterCountText = `${verifiedReporterCount} 🍇 reporters`;
                        }
                    }

                    let verifiedFollowerCountText = '';

                    if (verifiedFollowerCount == 1) {
                        verifiedFollowerCountText = `${verifiedFollowerCount} 🍇 follower`;
                    } else {
                        verifiedFollowerCountText = `${verifiedFollowerCount} 🍇 followers`;
                    }

                    // Format influence score for display
                    function formatInfluenceScore(score) {
                        if (score === 1 || score === 0) {
                            return score.toString();
                        }
                        return score.toFixed(2);
                    }
                    
                    const formattedInfluenceScore = formatInfluenceScore(influenceScore);
                    
                    // Create the profile panel HTML with trust score hover functionality and visual cues
                    const profileHTML = `
                        <div class="${cssClasses}" data-pubkey="${pubkey}" data-influence="${influenceScore}" data-reporter-count="${verifiedReporterCount}" data-effective-reporter-count="${effectiveReporterInput}" data-follower-count="${verifiedFollowerCount}" data-correction-factor="${correctionFactor}" style="${dynamicStyles}" onmouseenter="showTrustScoreTooltip(event, '${pubkey}')" onmouseleave="hideTrustScoreTooltip()">
                            <a href="/profile.html?pubkey=${pubkey}" target="_blank" class="profile-link">
                                <div class="profile-image">
                                    <img src="${picture}" alt="${displayName}" onerror="this.src='/control/img/default-avatar.svg'">
                                </div>
                                <div class="profile-info">
                                    <h3 class="profile-name">${displayName}</h3>
                                    <h3 class="profile-handle">@${name}</h3>
                                    <h3 class="profile-followers">${verifiedFollowerCountText}</h3>
                                    <h3 class="profile-reporters">${verifiedReporterCountText}</h3>
                                </div>
                                <div class="influence-score-circle">
                                    <span class="influence-score-value">${formattedInfluenceScore}</span>
                                </div>
                            </a>
                        </div>
                    `;
                    
                    // Return object with both HTML and influence score for sorting
                    return {
                        html: profileHTML,
                        influence: influenceScore,
                        pubkey: pubkey
                    };
                } else {
                    console.error('Failed to get profile data for pubkey:', pubkey, profileResult.error);
                    return null;
                }
            } catch (error) {
                console.error('Error getting profile data for pubkey:', pubkey, error);
                return null;
            }
        }
        
        // Trust score tooltip functionality
        let currentTooltip = null;
        let tooltipTimeout = null;
        const trustScoreCache = new Map();
        
        function showTrustScoreTooltip(event, pubkey) {
            // Clear any existing timeout
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }
            
            // Remove existing tooltip
            hideTrustScoreTooltip();
            
            // Create tooltip element
            currentTooltip = document.createElement('div');
            currentTooltip.className = 'trust-score-tooltip';
            currentTooltip.innerHTML = '<div class="trust-score-loading">Loading trust scores...</div>';
            
            // Add tooltip to DOM first (but keep it invisible)
            document.body.appendChild(currentTooltip);
            
            // Use requestAnimationFrame to ensure DOM is updated before positioning
            requestAnimationFrame(() => {
                if (currentTooltip) {
                    // Position tooltip after DOM update
                    positionTooltip(event, currentTooltip);
                    
                    // Show tooltip with animation after positioning
                    requestAnimationFrame(() => {
                        if (currentTooltip) {
                            currentTooltip.classList.add('show');
                            // Fetch trust score data after tooltip is positioned and shown
                            fetchTrustScoreData(pubkey);
                        }
                    });
                }
            });
        }
        
        function hideTrustScoreTooltip() {
            if (currentTooltip) {
                const tooltipToRemove = currentTooltip;
                currentTooltip = null; // Clear reference immediately to prevent race conditions
                
                tooltipToRemove.classList.remove('show');
                setTimeout(() => {
                    if (tooltipToRemove && tooltipToRemove.parentNode) {
                        tooltipToRemove.parentNode.removeChild(tooltipToRemove);
                    }
                }, 300);
            }
        }
        
        function positionTooltip(event, tooltip) {
            const rect = event.target.closest('.profile-card').getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // Account for page scroll position
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            // Calculate position relative to the document (not viewport)
            let left = rect.left + scrollX + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top + scrollY - tooltipRect.height - 15; // Increased gap to 15px
            
            // Adjust if tooltip goes off screen horizontally
            const minLeft = scrollX + 10;
            const maxLeft = scrollX + window.innerWidth - tooltipRect.width - 10;
            if (left < minLeft) left = minLeft;
            if (left > maxLeft) left = maxLeft;
            
            // Adjust if tooltip goes off screen vertically (place below instead of above)
            const minTop = scrollY + 10;
            if (top < minTop) {
                top = rect.bottom + scrollY + 15; // Increased gap to 15px when below
            }
            
            // Ensure tooltip doesn't overlap with the profile card area
            // Add extra safety margin to prevent any mouse event interference
            const cardBottom = rect.bottom + scrollY;
            const cardTop = rect.top + scrollY;
            
            // If positioning above, ensure there's sufficient clearance
            if (top + tooltipRect.height + 5 > cardTop) {
                top = cardBottom + 15;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        function fetchTrustScoreData(pubkey) {
            // Trust data is now pre-loaded during profile panel creation
            if (trustScoreCache.has(pubkey)) {
                const trustData = trustScoreCache.get(pubkey);
                if (trustData === null) {
                    displayTrustScoreError('Trust data not available');
                } else {
                    displayTrustScoreData(trustData);
                }
            } else {
                // Fallback: this shouldn't happen since data is pre-loaded
                displayTrustScoreError('Trust data not loaded');
            }
        }
        
        function displayTrustScoreData(data) {
            if (!currentTooltip) return;
            
            const formatNumber = (num) => {
                if (num === null || num === undefined) return 'N/A';
                if (typeof num === 'number') {
                    if (num < 0.001 && num > 0) {
                        return num.toExponential(2);
                    }
                    return num.toLocaleString(undefined, { maximumFractionDigits: 4 });
                }
                return num.toString();
            };
            
            const formatHops = (hops) => {
                if (hops === null || hops === undefined) return 'N/A';
                if (hops === 0) return 'Owner';
                if (hops === 1) return '1 hop';
                return `${hops} hops`;
            };
            
            currentTooltip.innerHTML = `
                <h4>🔒 Trust Scores</h4>
                <div class="trust-metrics">
                    <div class="trust-metric">
                        <span class="trust-metric-label">Distance:</span>
                        <span class="trust-metric-value">${formatHops(data.hops)}</span>
                    </div>
                    <div class="trust-metric">
                        <span class="trust-metric-label">Influence:</span>
                        <span class="trust-metric-value">${formatNumber(data.influence)}</span>
                    </div>
                    <div class="trust-metric">
                        <span class="trust-metric-label">PageRank:</span>
                        <span class="trust-metric-value">${formatNumber(data.personalizedPageRank)}</span>
                    </div>
                    <div class="trust-metric">
                        <span class="trust-metric-label">✅ Followers:</span>
                        <span class="trust-metric-value">${formatNumber(data.verifiedFollowerCount)}</span>
                    </div>
                    <div class="trust-metric">
                        <span class="trust-metric-label">🔇 Muters:</span>
                        <span class="trust-metric-value">${formatNumber(data.verifiedMuterCount)}</span>
                    </div>
                    <div class="trust-metric">
                        <span class="trust-metric-label">🚨 Reporters:</span>
                        <span class="trust-metric-value">${formatNumber(data.verifiedReporterCount)}</span>
                    </div>
                </div>
            `;
        }
        
        function displayTrustScoreError(message) {
            if (!currentTooltip) return;
            
            currentTooltip.innerHTML = `
                <h4>🔒 Trust Scores</h4>
                <div class="trust-score-error">${message}</div>
            `;
        }
        
        // Initialize observer selector when page loads
        document.addEventListener('DOMContentLoaded', function() {
            observerSelector = new ObserverSelector('observerSelectorContainer', {
                defaultValue: 'owner',
                onChange: function(selectedPubkey) {
                    currentObserverPubkey = selectedPubkey;
                    
                    // If there are existing search results, refresh them with the new observer perspective
                    if (searchResults.style.display !== 'none' && searchInput.value.trim().length >= 2) {
                        performSearch();
                    }
                }
            });
        });
    </script>
</body>
</html>