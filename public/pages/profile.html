<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainstorm</title>
    <link rel="stylesheet" href="/css/profile.css">
    <script src="./components/header/header.js"></script>
    <link rel="shortcut icon" href="/control/img/brainstorm010.svg">
    <script src="./components/footer/footer.js"></script>
</head>
<body>
    <!-- Include the header component -->
    <div id="headerContainer"></div>
    
    <!-- Main content wrapper -->
    <div class="page-content">
        <div class="container">
            <div class="header-profile">
                <h1>Nostr User Profile</h1>
            </div>
            
            <div id="loadingIndicator" class="loading"></div>
            
            <div id="errorMessage" class="error-message" style="display: none;"></div>
            
            <div id="profileContainer" class="profile-container" style="display: none;">
                <div class="profile-sidebar">
                    <img id="profilePicture" class="profile-picture" src="/img/default-avatar.png" alt="Profile Picture">
                    <div class="profile-info">
                        <h2 id="displayName">Loading...</h2>
                        <p id="username">@username</p>
                        <p id="nip05" style="display: none;"></p>
                        <div class="pubkey-display" id="pubkeyDisplay"></div>
                    </div>
                    <div class="profile-links" id="profileLinks">
                        <!-- Links will be added here -->
                        <a id="profileNjumpLink" href="#" target="_blank">view on njump.me</a>
                    </div>
                </div>
                
                <div class="profile-content">
                    <div class="profile-stats">
                        <div class="stat-box">
                            <h3>PageRank</h3>
                            <p id="pageRankValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Hops</h3>
                            <p id="hopsValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Influence</h3>
                            <p id="influenceValue">-</p>
                            <p class="stat-link"><a href="#" id="grapeRankReviewLink">Review Calculations</a></p>
                        </div>
                        <div class="stat-box">
                            <h3>Confidence</h3>
                            <p id="confidenceValue">-</p>
                        </div>
                    </div>
                    
                    <div class="profile-stats">
                        <div class="stat-box">
                            <h3>Following</h3>
                            <p id="followingCountValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Followers</h3>
                            <p id="followerCountValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Verified Followers<br/><h4>(influence > 0.05)</h4></h3>
                            <p id="verifiedFollowerCountValue">-</p>
                        </div>
                    </div>
                    
                    <div class="profile-stats">
                        <div class="stat-box">
                            <h3>Muting</h3>
                            <p id="mutingCountValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Muters</h3>
                            <p id="muterCountValue">-</p>
                        </div>
                    </div>
                    
                    <div class="profile-stats">
                        <div class="stat-box">
                            <h3>Reporting</h3>
                            <p id="reportingCountValue">-</p>
                        </div>
                        <div class="stat-box">
                            <h3>Reporters</h3>
                            <p id="reporterCountValue">-</p>
                        </div>
                    </div>
                    
                    <div class="profile-about" id="aboutSection">
                        <h3>About</h3>
                        <p id="aboutText">No information available</p>
                    </div>
                    
                    <div class="profile-metadata">
                        <h3>Profile Metadata</h3>
                        <table class="metadata-table" id="metadataTable">
                            <tbody>
                                <!-- Metadata will be added here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="network-visualization">
                        <h3>Network Proximity Visualization</h3>
                        <p><a href="network-visualization-lite.html?pubkey={{pubkey}}" id="networkLink" target="_blank">Open Network Visualization in New Tab</a> (Lite version to prevent server overload)</p>
                        <div id="networkContainer" class="network-container">
                            <div id="networkLoading" class="network-loading"></div>
                            <div id="networkLegend" class="network-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #3498db;"></div>
                                    <span>Center (This User)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                                    <span>Following</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #27ae60;"></div>
                                    <span>Followers</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #f39c12;"></div>
                                    <span>Muting</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #d35400;"></div>
                                    <span>Muters</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                                    <span>Reporting</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #c0392b;"></div>
                                    <span>Reporters</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer container -->
    <div id="footerContainer"></div>
    
    <!-- Include D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        // Get pubkey from URL
        const urlParams = new URLSearchParams(window.location.search);
        const pubkey = urlParams.get('pubkey');
        
        if (!pubkey) {
            showError('No pubkey specified. Please provide a valid pubkey parameter.');
        } else {
            // Configure GrapeRank Review link
            document.getElementById('grapeRankReviewLink').href = `graperank-calculations-review.html?pubkey=${pubkey}`;
            document.getElementById('profileNjumpLink').href = `https://njump.me/${pubkey}`;
            
            // Base URL for API calls
            const baseUrl = '/api';
            
            // Load data
            loadProfileDataSequentially(pubkey, baseUrl);
        }
        
        // Get DOM elements
        const profileContainer = document.getElementById('profileContainer');
        const errorMessage = document.getElementById('errorMessage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        // Determine the base URL for API calls
        const baseUrl = window.location.pathname.includes('/control/') ? '/control' : '';
        
        // Update network visualization link with the pubkey
        const networkLink = document.getElementById('networkLink');
        if (networkLink && pubkey) {
            networkLink.href = `network-visualization-lite.html?pubkey=${encodeURIComponent(pubkey)}`;
        }
        
        // Load profile data if pubkey is provided
        if (pubkey) {
            // Hide error message
            errorMessage.style.display = 'none';
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            profileContainer.style.display = 'none';
            
            // Set the pubkey in the display
            pubkeyDisplay.textContent = pubkey;
            
            // Sequential API calls to prevent concurrent request issues
            loadProfileDataSequentially(pubkey, baseUrl);
        } else {
            // Show error message if no pubkey is provided
            showError('No pubkey provided');
        }
        
        // Function to load profile data sequentially
        function loadProfileDataSequentially(pubkey, baseUrl) {
            // Step 1: Load Neo4j data
            fetch(`${baseUrl}/api/get-user-data?pubkey=${encodeURIComponent(pubkey)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayNeo4jData(data.data);
                        updateProfileStats(data.data);
                        
                        // Step 2: Only after Neo4j data is loaded, fetch kind 0 data
                        return fetch(`${baseUrl}/api/get-kind0?pubkey=${encodeURIComponent(pubkey)}`);
                    } else {
                        throw new Error(data.message || 'Failed to fetch Neo4j data');
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayKind0Data(data.data);
                        
                        // Show profile container
                        loadingIndicator.style.display = 'none';
                        profileContainer.style.display = 'flex';
                        
                        // Step 3: Only after kind 0 data is loaded, fetch network data
                        // Wait a short delay to ensure the previous request is fully complete
                        setTimeout(() => {
                            fetchAndDisplayNetworkData(pubkey, baseUrl);
                        }, 500);
                    } else {
                        // If we can't get kind 0 data, still show what we have
                        console.warn('Could not fetch kind 0 data:', data.message);
                        
                        // Show profile container
                        loadingIndicator.style.display = 'none';
                        profileContainer.style.display = 'flex';
                        
                        // Step 3: Fetch network data with a delay
                        setTimeout(() => {
                            fetchAndDisplayNetworkData(pubkey, baseUrl);
                        }, 500);
                    }
                })
                .catch(error => {
                    console.error('Error fetching profile data:', error);
                    showError(`Error fetching profile data: ${error.message}`);
                });
        }
        
        // Function to display Neo4j data
        function displayNeo4jData(data) {
            // Update the profile stats with Neo4j data
            if (data.personalizedPageRank !== null && data.personalizedPageRank !== undefined) {
                pageRankValue.textContent = parseFloat(data.personalizedPageRank).toFixed(4);
            }
            
            if (data.hops !== null && data.hops !== undefined) {
                hopsValue.textContent = data.hops;
            }
            
            if (data.influence !== null && data.influence !== undefined) {
                influenceValue.textContent = parseFloat(data.influence).toFixed(4);
            }
            
            if (data.confidence !== null && data.confidence !== undefined) {
                confidenceValue.textContent = parseFloat(data.confidence).toFixed(4);
            }
            
            if (data.followingCount !== null && data.followingCount !== undefined) {
                followingCountValue.textContent = data.followingCount;
            }
            
            if (data.followerCount !== null && data.followerCount !== undefined) {
                followerCountValue.textContent = data.followerCount;
            }

            if (data.verifiedFollowerCount !== null && data.verifiedFollowerCount !== undefined) {
                verifiedFollowerCountValue.textContent = data.verifiedFollowerCount;
            }
            
            if (data.mutingCount !== null && data.mutingCount !== undefined) {
                mutingCountValue.textContent = data.mutingCount;
            }
            
            if (data.muterCount !== null && data.muterCount !== undefined) {
                muterCountValue.textContent = data.muterCount;
            }
            
            if (data.reportingCount !== null && data.reportingCount !== undefined) {
                reportingCountValue.textContent = data.reportingCount;
            }
            
            if (data.reporterCount !== null && data.reporterCount !== undefined) {
                reporterCountValue.textContent = data.reporterCount;
            }
        }
        
        // Function to display kind 0 data
        function displayKind0Data(data) {
            if (!data || !data.content) {
                return;
            }
            
            try {
                // Parse the content as JSON
                const profileContent = JSON.parse(data.content);
                
                // Update display name
                if (profileContent.name) {
                    displayName.textContent = profileContent.name;
                    document.title = `${profileContent.name} - Nostr Profile`;
                }
                
                // Update username/nickname
                if (profileContent.display_name || profileContent.displayName) {
                    const nick = profileContent.display_name || profileContent.displayName;
                    username.textContent = nick;
                } else if (profileContent.name) {
                    username.textContent = `@${profileContent.name.toLowerCase().replace(/\s+/g, '_')}`;
                }
                
                // Update profile picture
                if (profileContent.picture) {
                    profilePicture.src = profileContent.picture;
                    profilePicture.onerror = () => {
                        profilePicture.src = '/img/default-avatar.png';
                    };
                }
                
                // Update NIP-05 identifier
                if (profileContent.nip05) {
                    nip05.textContent = `âœ“ ${profileContent.nip05}`;
                    nip05.style.display = 'block';
                }
                
                // Update about text
                if (profileContent.about) {
                    aboutText.textContent = profileContent.about;
                    
                    // Convert URLs to links
                    aboutText.innerHTML = aboutText.innerHTML.replace(
                        /(https?:\/\/[^\s]+)/g, 
                        '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
                    );
                }
                
                // Add website link if available
                if (profileContent.website) {
                    addProfileLink('Website', profileContent.website);
                }
                
                // Add social media links
                const socialPlatforms = {
                    twitter: { label: 'Twitter', url: 'https://twitter.com/' },
                    github: { label: 'GitHub', url: 'https://github.com/' },
                    instagram: { label: 'Instagram', url: 'https://instagram.com/' },
                    linkedin: { label: 'LinkedIn', url: 'https://linkedin.com/in/' }
                };
                
                for (const [platform, info] of Object.entries(socialPlatforms)) {
                    if (profileContent[platform]) {
                        const username = profileContent[platform].replace('@', '');
                        addProfileLink(info.label, `${info.url}${username}`);
                    }
                }
                
                // Add all metadata to the table
                metadataTable.innerHTML = '';
                for (const [key, value] of Object.entries(profileContent)) {
                    if (value && typeof value === 'string') {
                        addMetadataRow(key, value);
                    }
                }
                
                // Add event metadata
                if (data.created_at) {
                    const date = new Date(data.created_at * 1000);
                    addMetadataRow('Profile Updated', date.toLocaleString());
                }
                
                if (data.id) {
                    addMetadataRow('Event ID', data.id);
                }
            } catch (error) {
                console.error('Error parsing profile content:', error);
            }
        }
        
        // Function to update profile stats
        function updateProfileStats(userData) {
            // Update the profile stats with Neo4j data
            if (userData.personalizedPageRank !== null && userData.personalizedPageRank !== undefined) {
                pageRankValue.textContent = parseFloat(userData.personalizedPageRank).toFixed(4);
            }
            
            if (userData.hops !== null && userData.hops !== undefined) {
                hopsValue.textContent = userData.hops;
            }
            
            if (userData.influence !== null && userData.influence !== undefined) {
                influenceValue.textContent = parseFloat(userData.influence).toFixed(4);
            }
            
            if (userData.confidence !== null && userData.confidence !== undefined) {
                confidenceValue.textContent = parseFloat(userData.confidence).toFixed(4);
            }
            
            if (userData.followingCount !== null && userData.followingCount !== undefined) {
                followingCountValue.textContent = userData.followingCount;
            }
            
            if (userData.followerCount !== null && userData.followerCount !== undefined) {
                followerCountValue.textContent = userData.followerCount;
            }
            
            if (userData.verifiedFollowerCount !== null && userData.verifiedFollowerCount !== undefined) {
                verifiedFollowerCountValue.textContent = userData.verifiedFollowerCount;
            }
            
            if (userData.mutingCount !== null && userData.mutingCount !== undefined) {
                mutingCountValue.textContent = userData.mutingCount;
            }
            
            if (userData.muterCount !== null && userData.muterCount !== undefined) {
                muterCountValue.textContent = userData.muterCount;
            }
            
            if (userData.reportingCount !== null && userData.reportingCount !== undefined) {
                reportingCountValue.textContent = userData.reportingCount;
            }
            
            if (userData.reporterCount !== null && userData.reporterCount !== undefined) {
                reporterCountValue.textContent = userData.reporterCount;
            }
        }
        
        // Function to add profile link
        function addProfileLink(label, url) {
            const link = document.createElement('a');
            link.href = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = label;
            profileLinks.appendChild(link);
        }
        
        // Function to add metadata row
        function addMetadataRow(key, value) {
            const row = document.createElement('tr');
            
            const keyCell = document.createElement('th');
            keyCell.textContent = key.replace(/([A-Z])/g, ' $1')
                .replace(/_/g, ' ')
                .replace(/^./, str => str.toUpperCase());
            
            const valueCell = document.createElement('td');
            
            // Check if value is a URL
            if (value.match(/^https?:\/\//)) {
                const link = document.createElement('a');
                link.href = value;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.textContent = value;
                valueCell.appendChild(link);
            } else {
                valueCell.textContent = value;
            }
            
            row.appendChild(keyCell);
            row.appendChild(valueCell);
            metadataTable.appendChild(row);
        }
        
        // Function to show error message
        function showError(message) {
            loadingIndicator.style.display = 'none';
            profileContainer.style.display = 'none';
            errorMessage.style.display = 'block';
            errorMessage.textContent = message;
        }
        
        // Function to fetch and display network data
        function fetchAndDisplayNetworkData(pubkey, baseUrl) {
            // Show network loading state
            const networkLoading = document.getElementById('networkLoading');
            if (networkLoading) {
                networkLoading.style.display = 'flex';
            }
            
            // Use the absolute URL that we know works directly in the browser
            const apiUrl = `${window.location.origin}/control/api/get-network-proximity?pubkey=${encodeURIComponent(pubkey)}&limit=50`;
            console.log('Fetching network data from:', apiUrl);
            
            // Create a new XMLHttpRequest with timeout
            const xhr = new XMLHttpRequest();
            xhr.open('GET', apiUrl, true);
            xhr.timeout = 30000; // 30 second timeout
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.setRequestHeader('Cache-Control', 'no-cache');
            
            xhr.onload = function() {
                console.log('XHR status:', xhr.status);
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const data = JSON.parse(xhr.responseText);
                        console.log('Network data received:', data);
                        if (data.success) {
                            renderNetworkVisualization(data.data);
                        } else {
                            console.error('Failed to fetch network data:', data.message);
                            document.getElementById('networkContainer').innerHTML = 
                                `<div class="error-message">Failed to load network data: ${data.message}</div>`;
                        }
                    } catch (e) {
                        console.error('Error parsing JSON response:', e);
                        document.getElementById('networkContainer').innerHTML = 
                            `<div class="error-message">Error parsing network data: ${e.message}</div>`;
                    }
                } else {
                    console.error('XHR error:', xhr.status, xhr.statusText);
                    document.getElementById('networkContainer').innerHTML = 
                        `<div class="error-message">Error loading network data: ${xhr.status} ${xhr.statusText}</div>`;
                }
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            xhr.ontimeout = function() {
                console.error('Network request timed out');
                document.getElementById('networkContainer').innerHTML = 
                    '<div class="error-message">Network request timed out. The server might be busy processing the request.</div>';
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            xhr.onerror = function() {
                console.error('Network request failed');
                document.getElementById('networkContainer').innerHTML = 
                    '<div class="error-message">Network request failed. Please check your connection and try again.</div>';
                
                // Hide network loading state
                if (networkLoading) {
                    networkLoading.style.display = 'none';
                }
            };
            
            // Send the request
            xhr.send();
        }
        
        // Function to render network visualization
        function renderNetworkVisualization(data) {
            try {
                // Check if we have valid data
                if (!data || !data.nodes || !data.links || data.nodes.length === 0) {
                    document.getElementById('networkContainer').innerHTML = 
                        '<div class="error-message">No network data available for this user.</div>';
                    return;
                }
                
                // Log data for debugging
                console.log('Rendering network with nodes:', data.nodes.length, 'links:', data.links.length);
                
                // Ensure all nodes have an id property
                data.nodes.forEach((node, index) => {
                    if (!node.id) {
                        console.warn('Node missing id, adding one:', node);
                        node.id = node.pubkey || `node_${index}`;
                    }
                    
                    // Initialize profilePicture property
                    node.profilePicture = null;
                    
                    // Set a minimum influence value to avoid tiny nodes
                    if (!node.influence || node.influence < 0.0001) {
                        node.influence = 0.0001;
                    }
                });
                
                // Define link colors based on relationship type
                const linkColors = {
                    'following': '#2ecc71',
                    'followers': '#27ae60',
                    'muting': '#f39c12',
                    'muters': '#d35400',
                    'reporting': '#e74c3c',
                    'reporters': '#c0392b'
                };
                
                // Create SVG container
                const svg = d3.select('#networkContainer')
                    .append('svg')
                    .attr('width', 600)
                    .attr('height', 400);
                
                // Add arrow markers for directional links
                svg.append("defs").selectAll("marker")
                    .data(["following", "followers", "muting", "muters", "reporting", "reporters"])
                    .enter().append("marker")
                    .attr("id", d => `arrow-${d}`)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 25)  // Position the arrow away from the node
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", d => linkColors[d] || "#999");
                
                // Add defs for profile picture patterns
                const defs = svg.append("defs");
                
                // Create patterns for each node with a profile picture
                data.nodes.forEach(node => {
                    if (node.profilePicture) {
                        console.log(`Creating pattern for ${node.id} with image ${node.profilePicture}`);
                        
                        // Create a pattern with a unique ID
                        const patternId = `profile-pic-${node.id.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        
                        // Create a pattern for the profile picture
                        const pattern = defs.append("pattern")
                            .attr("id", patternId)
                            .attr("patternUnits", "objectBoundingBox")
                            .attr("width", 1)
                            .attr("height", 1);
                        
                        // Add a white background circle to ensure the image is visible
                        pattern.append("circle")
                            .attr("cx", 0.5)
                            .attr("cy", 0.5)
                            .attr("r", 0.5)
                            .attr("fill", "white");
                        
                        // Add the image to the pattern
                        pattern.append("image")
                            .attr("xlink:href", node.profilePicture)
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", 1)
                            .attr("height", 1)
                            .attr("preserveAspectRatio", "xMidYMid slice");
                        
                        // Store the pattern ID in the node for reference
                        node.patternId = patternId;
                    }
                });
                
                // Create tooltip
                const tooltip = d3.select('#networkContainer')
                    .append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute')
                    .style('background-color', 'white')
                    .style('border', '1px solid #ddd')
                    .style('border-radius', '4px')
                    .style('padding', '8px')
                    .style('pointer-events', 'none')
                    .style('font-size', '12px')
                    .style('z-index', '10')
                    .style('max-width', '300px');
                
                // Calculate node radius based on influence
                const influenceScale = d3.scaleSqrt()
                    .domain([
                        d3.min(data.nodes, d => d.influence || 0.0001),
                        d3.max(data.nodes, d => d.influence || 1)
                    ])
                    .range([5, 25]);  // Min and max radius
                
                // Create force simulation
                const simulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(data.links)
                        .id(d => d.id)
                        .distance(d => {
                            // Make distance dependent on node sizes
                            const sourceNode = data.nodes.find(n => n.id === d.source);
                            const targetNode = data.nodes.find(n => n.id === d.target);
                            const sourceRadius = influenceScale(sourceNode.influence || 0.0001);
                            const targetRadius = influenceScale(targetNode.influence || 0.0001);
                            return 100 + sourceRadius + targetRadius;
                        }))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(300, 200))
                    .force('collision', d3.forceCollide().radius(d => influenceScale(d.influence || 0.0001) + 5));
                
                // Create links as paths for directional arrows
                const link = svg.append('g')
                    .selectAll('path')
                    .data(data.links)
                    .enter()
                    .append('path')
                    .attr('stroke', d => linkColors[d.type] || '#999')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 2)
                    .attr('fill', 'none')
                    .attr('marker-end', d => `url(#arrow-${d.type})`);
                
                // Create node groups
                const nodeGroup = svg.append('g')
                    .selectAll('g')
                    .data(data.nodes)
                    .enter()
                    .append('g')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                // Add circle for each node
                const node = nodeGroup.append('circle')
                    .attr('r', d => influenceScale(d.influence || 0.0001))
                    .attr('fill', d => {
                        // Use profile picture if available, otherwise use color
                        if (d.patternId) {
                            return `url(#${d.patternId})`;
                        }
                        return '#999';
                    })
                    .attr('stroke', d => '#999')
                    .attr('stroke-width', 2);
                
                // Add node labels
                const labels = nodeGroup.append('text')
                    .text(d => {
                        // Show short name for center node, nothing for others to avoid clutter
                        if (d.type === 'center') {
                            return d.name || d.id.substring(0, 6) + '...';
                        }
                        return '';
                    })
                    .attr('font-size', '10px')
                    .attr('dx', d => influenceScale(d.influence || 0.0001) + 5)
                    .attr('dy', 4)
                    .attr('fill', '#333');
                
                // Add hover effects and tooltips
                nodeGroup.on('mouseover', function(event, d) {
                        // Highlight connected links and nodes
                        link.style('stroke-opacity', l => {
                            // Check if the link is connected to this node
                            const sourceId = l.source.id || l.source;
                            const targetId = l.target.id || l.target;
                            return sourceId === d.id || targetId === d.id ? 1 : 0.1;
                        });
                        
                        nodeGroup.style('opacity', n => {
                            // Check if this node is connected to the hovered node
                            if (n.id === d.id) return 1;
                            
                            // Check if there's a link between these nodes
                            const connected = data.links.some(l => {
                                const sourceId = l.source.id || l.source;
                                const targetId = l.target.id || l.target;
                                return (sourceId === d.id && targetId === n.id) || 
                                       (sourceId === n.id && targetId === d.id);
                            });
                            
                            return connected ? 1 : 0.3;
                        });
                        
                        // Show tooltip
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', .9);
                        
                        // Format tooltip content with detailed web of trust scores
                        let tooltipContent = `
                            <div style="text-align: center; margin-bottom: 8px;">
                                ${d.profilePicture ? `<img src="${d.profilePicture}" style="width: 50px; height: 50px; border-radius: 25px; margin-bottom: 5px;">` : ''}
                                <strong>${d.name || (d.id || '').substring(0, 10) + '...'}</strong>
                            </div>
                            <div style="font-size: 11px; color: #666;">Pubkey: ${(d.id || '').substring(0, 10)}...</div>
                            <hr style="margin: 5px 0; border-top: 1px solid #eee;">
                            <div><strong>Web of Trust Scores:</strong></div>
                            <div>Hops: ${d.hops !== undefined && d.hops !== null ? d.hops : 'N/A'}</div>
                            <div>Influence: ${d.influence !== undefined && d.influence !== null ? parseFloat(d.influence).toFixed(6) : 'N/A'}</div>
                            <div>PageRank: ${d.personalizedPageRank !== undefined && d.personalizedPageRank !== null ? parseFloat(d.personalizedPageRank).toFixed(6) : 'N/A'}</div>
                            <div>Relationship: ${d.type || 'N/A'}</div>
                        `;
                        
                        tooltip.html(tooltipContent)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        // Reset link and node opacity
                        link.style('stroke-opacity', 0.6);
                        nodeGroup.style('opacity', 1);
                        
                        // Hide tooltip
                        tooltip.transition()
                            .duration(500)
                            .style('opacity', 0);
                    });
                
                // Add simulation tick handler
                simulation.on('tick', () => {
                    // Update link paths for curved directional links
                    link.attr('d', d => {
                        // Get source and target nodes
                        const source = data.nodes.find(n => n.id === d.source);
                        const target = data.nodes.find(n => n.id === d.target);
                        
                        // Safety check for valid coordinates
                        if (!source || !target || 
                            typeof source.x !== 'number' || typeof source.y !== 'number' ||
                            typeof target.x !== 'number' || typeof target.y !== 'number' ||
                            isNaN(source.x) || isNaN(source.y) || 
                            isNaN(target.x) || isNaN(target.y)) {
                            return ''; // Return empty path if coordinates are invalid
                        }
                        
                        // Calculate path for directional arrow
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        
                        // Safety check for zero length
                        if (length === 0) {
                            return ''; // Return empty path if length is zero
                        }
                        
                        // Calculate the normalized direction vector
                        const normX = dx / length;
                        const normY = dy / length;
                        
                        // Get node radii
                        const sourceRadius = influenceScale(source.influence || 0.0001);
                        const targetRadius = influenceScale(target.influence || 0.0001);
                        
                        // Calculate start and end points, offset by node radius
                        const startX = source.x + (sourceRadius * normX);
                        const startY = source.y + (sourceRadius * normY);
                        const endX = target.x - (targetRadius * normX);
                        const endY = target.y - (targetRadius * normY);
                        
                        // Safety check for valid path points
                        if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
                            return ''; // Return empty path if any coordinate is NaN
                        }
                        
                        // Return a straight line instead of a curve to avoid arc calculation issues
                        return `M${startX},${startY}L${endX},${endY}`;
                    });
                    
                    // Update node group positions
                    nodeGroup.attr('transform', d => {
                        // Safety check for valid coordinates
                        if (typeof d.x !== 'number' || typeof d.y !== 'number' || isNaN(d.x) || isNaN(d.y)) {
                            d.x = 300;
                            d.y = 200;
                        }
                        
                        // Keep nodes within bounds
                        const radius = influenceScale(d.influence || 0.0001);
                        d.x = Math.max(radius, Math.min(600 - radius, d.x));
                        d.y = Math.max(radius, Math.min(400 - radius, d.y));
                        
                        return `translate(${d.x}, ${d.y})`;
                    });
                });
                
                // Add a legend for relationship types
                const legend = svg.append('g')
                    .attr('class', 'legend')
                    .attr('transform', 'translate(20, 20)');
                
                const legendItems = [
                    { type: 'center', label: 'Center User' },
                    { type: 'following', label: 'Following' },
                    { type: 'followers', label: 'Followers' },
                    { type: 'muting', label: 'Muting' },
                    { type: 'muters', label: 'Muters' },
                    { type: 'reporting', label: 'Reporting' },
                    { type: 'reporters', label: 'Reporters' }
                ];
                
                legendItems.forEach((item, i) => {
                    const legendItem = legend.append('g')
                        .attr('transform', `translate(0, ${i * 20})`);
                    
                    legendItem.append('circle')
                        .attr('r', 6)
                        .attr('fill', item.type === 'center' ? '#3498db' : linkColors[item.type] || '#999');
                    
                    legendItem.append('text')
                        .attr('x', 15)
                        .attr('y', 4)
                        .text(item.label)
                        .attr('font-size', '12px');
                });
                
                // Add an influence scale legend
                const influenceLegend = svg.append('g')
                    .attr('class', 'influence-legend')
                    .attr('transform', `translate(${600 - 150}, 20)`);
                
                influenceLegend.append('text')
                    .attr('x', 0)
                    .attr('y', 0)
                    .text('Influence Scale:')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold');
                
                // Show 3 example sizes
                const influenceExamples = [
                    { label: 'Low', value: d3.min(data.nodes, d => d.influence || 0.0001) },
                    { label: 'Medium', value: (d3.min(data.nodes, d => d.influence || 0.0001) + d3.max(data.nodes, d => d.influence || 1)) / 2 },
                    { label: 'High', value: d3.max(data.nodes, d => d.influence || 1) }
                ];
                
                influenceExamples.forEach((example, i) => {
                    const exampleItem = influenceLegend.append('g')
                        .attr('transform', `translate(30, ${i * 30 + 20})`);
                    
                    exampleItem.append('circle')
                        .attr('r', influenceScale(example.value))
                        .attr('fill', '#999')
                        .attr('opacity', 0.5);
                    
                    exampleItem.append('text')
                        .attr('x', 35)
                        .attr('y', 4)
                        .text(`${example.label}: ${example.value.toFixed(6)}`)
                        .attr('font-size', '10px');
                });
            } catch (error) {
                console.error('Error rendering network visualization:', error);
                document.getElementById('networkContainer').innerHTML = 
                    `<div class="error-message">Error rendering network visualization: ${error.message}</div>`;
            }
        }
        
        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    </script>
</body>
</html>
