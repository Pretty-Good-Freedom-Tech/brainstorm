<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo4j Health Dashboard - Brainstorm</title>
    <link rel="stylesheet" href="../css/neo4j-health-dashboard.css">
    <link rel="shortcut icon" href="/control/img/brainstorm010.svg">
    <script src="./components/header/header.js"></script>
    <script src="./components/footer/footer.js"></script>
    <script src="/libs/chart.js/chart.umd.js"></script>
    <script src="/libs/chartjs-adapter-date-fns/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <!-- Include the header component -->
    <div id="headerContainer"></div>
    
    <!-- Main content wrapper -->
    <div class="page-content">
        <div class="container">
            <div class="dashboard-container">
            <header>
                <h1>üîç Neo4j Health Dashboard</h1>
                <p>Comprehensive Neo4j stability monitoring and crash pattern detection</p>
            </header>
            
            <div class="refresh-controls">
                <div class="auto-refresh">
                    <label>
                        <input type="checkbox" id="autoRefresh" checked> Auto-refresh (30s)
                    </label>
                    <button class="btn btn-primary" onclick="refreshDashboard()">üîÑ Refresh Now</button>
                </div>
                <div>
                    <span id="lastUpdated">Last updated: Never</span>
                </div>
            </div>
            
            <!-- Metric View Selector -->
            <div class="metric-selector">
                <h3>üìä Choose Memory Metrics to Display</h3>
                <div class="metric-buttons">
                    <button class="metric-btn active" data-view="overview" onclick="switchMetricView('overview')">
                        üè† Overview
                    </button>
                    <button class="metric-btn" data-view="heap" onclick="switchMetricView('heap')">
                        üß† Heap Memory
                    </button>
                    <button class="metric-btn" data-view="metaspace" onclick="switchMetricView('metaspace')">
                        üîß Metaspace
                    </button>
                    <button class="metric-btn" data-view="compressed" onclick="switchMetricView('compressed')">
                        ‚ö†Ô∏è Compressed Classes
                    </button>
                    <button class="metric-btn" data-view="survivor" onclick="switchMetricView('survivor')">
                        üîÑ Survivor Spaces
                    </button>
                    <button class="metric-btn" data-view="gc" onclick="switchMetricView('gc')">
                        üóëÔ∏è Garbage Collection
                    </button>
                </div>
            </div>

            <!-- Metric Explanation Panel -->
            <div class="metric-explanation" id="metricExplanation">
                <div class="explanation-content" id="explanationContent">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>

            <!-- Heap Usage Time Series -->
            <div class="health-card">
                <div class="card-header">
                    <h3 class="card-title">üìà Memory Metrics Over Time</h3>
                    <option value="2160">Last 90 days</option>
                        </select>
                        <div class="data-source-indicator" id="dataSourceIndicator" style="font-size: 0.8em; color: #666; margin-top: 4px;"></div>
                    </div>
                </div>
                <div class="chart-container" style="height: 400px;">
                    <canvas id="heapChart"></canvas>
                </div>
            </div>

            <div class="dashboard-grid">
                <!-- Service Status Card -->
                <div class="health-card" id="serviceStatusCard">
                    <div class="card-header">
                        <h3 class="card-title">üöÄ Service Status</h3>
                        <span class="status-badge" id="serviceStatus">Loading...</span>
                    </div>
                    <div id="serviceMetrics">
                        <div class="metric-row">
                            <span class="metric-label">Process ID:</span>
                            <span class="metric-value" id="neo4jPid">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Memory Usage:</span>
                            <span class="metric-value" id="memoryUsage">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Connection Test:</span>
                            <span class="metric-value" id="connectionTest">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Response Time:</span>
                            <span class="metric-value" id="responseTime">-</span>
                        </div>
                    </div>
                </div>
                
                <!-- Heap Health Card -->
                <div class="health-card" id="heapHealthCard">
                    <div class="card-header">
                        <h3 class="card-title">üß† Heap Health</h3>
                        <span class="status-badge" id="heapStatus">Loading...</span>
                    </div>
                    <div id="heapMetrics">
                        <div class="metric-row">
                            <span class="metric-label">Heap Utilization:</span>
                            <span class="metric-value" id="heapUtilization">-</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="heapProgressBar" style="width: 0%"></div>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Used / Total:</span>
                            <span class="metric-value" id="heapUsedTotal">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">GC Overhead:</span>
                            <span class="metric-value" id="gcOverhead">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Full GC Count:</span>
                            <span class="metric-value" id="fullGcCount">-</span>
                        </div>
                    </div>
                </div>
                
                <!-- Index Health Card -->
                <div class="health-card" id="indexHealthCard">
                    <div class="card-header">
                        <h3 class="card-title">üìä Index Health</h3>
                        <span class="status-badge" id="indexStatus">Loading...</span>
                    </div>
                    <div id="indexMetrics">
                        <div class="metric-row">
                            <span class="metric-label">Total Indexes:</span>
                            <span class="metric-value" id="totalIndexes">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Failed Indexes:</span>
                            <span class="metric-value" id="failedIndexes">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Constraints:</span>
                            <span class="metric-value" id="totalConstraints">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Query Timeout:</span>
                            <span class="metric-value" id="queryTimeout">-</span>
                        </div>
                    </div>
                </div>
                
                <!-- Crash Patterns Card -->
                <div class="health-card" id="crashPatternsCard">
                    <div class="card-header">
                        <h3 class="card-title">‚ö†Ô∏è Crash Patterns</h3>
                        <span class="status-badge" id="crashPatternStatus">Loading...</span>
                    </div>
                    <div id="crashPatternMetrics">
                        <div class="metric-row">
                            <span class="metric-label">Heap Space OOM:</span>
                            <span class="metric-value" id="heapSpaceOom">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">GC Overhead OOM:</span>
                            <span class="metric-value" id="gcOverheadOom">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Metaspace OOM:</span>
                            <span class="metric-value" id="metaspaceOom">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Native Thread OOM:</span>
                            <span class="metric-value" id="nativeThreadOom">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">APOC Stalling:</span>
                            <span class="metric-value" id="apocStalling">-</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Long Transactions:</span>
                            <span class="metric-value" id="longTransactions">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Recent Alerts Section -->
            <div class="health-card">
                <div class="card-header">
                    <h3 class="card-title">üö® Recent Health Alerts</h3>
                    <button class="btn btn-secondary" onclick="clearAlerts()">Clear Alerts</button>
                </div>
                <div class="alert-list" id="alertsList">
                    <p>Loading alerts...</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Include the footer component -->
    <div id="footerContainer"></div>
    <script>
        let autoRefreshInterval;
        let dashboardData = {};
        let heapChart = null;
        
        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            refreshDashboard();
            setupAutoRefresh();
            initializeHeapChart();
        });
        
        // Setup auto-refresh
        function setupAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            
            if (autoRefreshCheckbox.checked) {
                autoRefreshInterval = setInterval(refreshDashboard, 30000);
            }
            
            autoRefreshCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    autoRefreshInterval = setInterval(refreshDashboard, 30000);
                } else {
                    clearInterval(autoRefreshInterval);
                }
            });
        }
        
        // Main refresh function
        async function refreshDashboard() {
            try {
                document.body.classList.add('loading');
                
                // Also update heap chart on refresh
                if (heapChart) {
                    await updateHeapChart();
                }
                
                // Fetch Neo4j health data
                const healthResponse = await fetch('/api/neo4j-health/complete');
                const healthData = await healthResponse.json();
                
                // Fetch recent alerts
                const alertsResponse = await fetch('/api/neo4j-health/alerts?component=neo4j&limit=20');
                const alertsData = await alertsResponse.json();
                
                // Update dashboard
                updateServiceStatus(healthData.service || {});
                updateHeapHealth(healthData.heap || {});
                updateIndexHealth(healthData.indexes || {});
                updateCrashPatterns(healthData.crashPatterns || {});
                updateAlerts(alertsData.alerts || []);
                
                // Update timestamp
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${new Date().toLocaleTimeString()}`;
                
            } catch (error) {
                console.error('Failed to refresh dashboard:', error);
                showError('Failed to fetch Neo4j health data');
            } finally {
                document.body.classList.remove('loading');
            }
        }
        
        // Update service status card
        function updateServiceStatus(data) {
            const card = document.getElementById('serviceStatusCard');
            const statusBadge = document.getElementById('serviceStatus');
            
            if (data.status === 'running') {
                card.className = 'health-card success';
                statusBadge.className = 'status-badge status-running';
                statusBadge.textContent = 'Running';
            } else {
                card.className = 'health-card critical';
                statusBadge.className = 'status-badge status-critical';
                statusBadge.textContent = 'Down';
            }
            
            document.getElementById('neo4jPid').textContent = data.pid || 'N/A';
            document.getElementById('memoryUsage').textContent = data.memoryMB ? `${data.memoryMB} MB` : 'N/A';
            document.getElementById('connectionTest').textContent = data.connectionTest || 'Unknown';
            document.getElementById('responseTime').textContent = data.responseTime || 'N/A';
        }
        
        // Update heap health card
        function updateHeapHealth(data) {
            const card = document.getElementById('heapHealthCard');
            const statusBadge = document.getElementById('heapStatus');
            const progressBar = document.getElementById('heapProgressBar');
            
            const heapPercent = data.utilizationPercent || 0;
            
            if (heapPercent >= 95) {
                card.className = 'health-card critical';
                statusBadge.className = 'status-badge status-critical';
                statusBadge.textContent = 'Critical';
                progressBar.className = 'progress-fill progress-critical';
            } else if (heapPercent >= 80) {
                card.className = 'health-card warning';
                statusBadge.className = 'status-badge status-warning';
                statusBadge.textContent = 'Warning';
                progressBar.className = 'progress-fill progress-warning';
            } else {
                card.className = 'health-card success';
                statusBadge.className = 'status-badge status-running';
                statusBadge.textContent = 'Healthy';
                progressBar.className = 'progress-fill progress-normal';
            }
            
            progressBar.style.width = `${heapPercent}%`;
            
            document.getElementById('heapUtilization').textContent = `${heapPercent}%`;
            document.getElementById('heapUsedTotal').textContent = 
                data.usedMB && data.totalMB ? `${data.usedMB} / ${data.totalMB} MB` : 'N/A';
            document.getElementById('gcOverhead').textContent = data.gcOverheadPercent ? `${data.gcOverheadPercent}%` : 'N/A';
            document.getElementById('fullGcCount').textContent = data.fullGcCount || '0';
        }
        
        // Update index health card
        function updateIndexHealth(data) {
            const card = document.getElementById('indexHealthCard');
            const statusBadge = document.getElementById('indexStatus');
            
            const failedIndexes = data.failedIndexes || 0;
            const totalIndexes = data.totalIndexes || 0;
            
            if (failedIndexes > 0) {
                card.className = 'health-card critical';
                statusBadge.className = 'status-badge status-critical';
                statusBadge.textContent = 'Issues';
            } else if (totalIndexes < 5) {
                card.className = 'health-card warning';
                statusBadge.className = 'status-badge status-warning';
                statusBadge.textContent = 'Insufficient';
            } else {
                card.className = 'health-card success';
                statusBadge.className = 'status-badge status-running';
                statusBadge.textContent = 'Healthy';
            }
            
            document.getElementById('totalIndexes').textContent = totalIndexes;
            document.getElementById('failedIndexes').textContent = failedIndexes;
            document.getElementById('totalConstraints').textContent = data.totalConstraints || '0';
            document.getElementById('queryTimeout').textContent = data.queryTimeout ? 'Yes' : 'No';
        }
        
        // Update crash patterns card
        function updateCrashPatterns(data) {
            const card = document.getElementById('crashPatternsCard');
            const statusBadge = document.getElementById('crashPatternStatus');
            
            const totalIssues = (data.heapSpaceOom || 0) + (data.gcOverheadOom || 0) + 
                              (data.metaspaceOom || 0) + (data.nativeThreadOom || 0) +
                              (data.apocStalling || 0) + (data.longTransactions || 0);
            
            if (totalIssues > 0) {
                card.className = 'health-card warning';
                statusBadge.className = 'status-badge status-warning';
                statusBadge.textContent = `${totalIssues} Issues`;
            } else {
                card.className = 'health-card success';
                statusBadge.className = 'status-badge status-running';
                statusBadge.textContent = 'No Issues';
            }
            
            document.getElementById('heapSpaceOom').textContent = data.heapSpaceOom || '0';
            document.getElementById('gcOverheadOom').textContent = data.gcOverheadOom || '0';
            document.getElementById('metaspaceOom').textContent = data.metaspaceOom || '0';
            document.getElementById('nativeThreadOom').textContent = data.nativeThreadOom || '0';
            document.getElementById('apocStalling').textContent = data.apocStalling || '0';
            document.getElementById('longTransactions').textContent = data.longTransactions || '0';
        }
        
        // Update alerts list
        function updateAlerts(alerts) {
            const alertsList = document.getElementById('alertsList');
            
            if (!alerts || alerts.length === 0) {
                alertsList.innerHTML = '<p>No recent alerts</p>';
                return;
            }
            
            const alertsHtml = alerts.map(alert => {
                const alertClass = alert.severity === 'critical' ? 'alert-critical' : 'alert-warning';
                const timestamp = new Date(alert.timestamp).toLocaleString();
                
                // Add clickable link for NEO4J_HIGH_ERROR_RATE alerts
                let alertContent = `<strong>${alert.alertType}</strong>: ${alert.message}`;
                if (alert.alertType === 'NEO4J_HIGH_ERROR_RATE') {
                    alertContent = `<strong>${alert.alertType}</strong>: ${alert.message} <a href="/neo4j-error-logs.html?hours=24&severity=all" target="_blank" style="color: #007bff; text-decoration: underline; margin-left: 8px;">üìã View Error Logs</a>`;
                }
                
                return `
                    <div class="alert-item ${alertClass}">
                        ${alertContent}
                        <div class="alert-timestamp">${timestamp}</div>
                        ${alert.recommendedAction ? `<div><em>Action: ${alert.recommendedAction}</em></div>` : ''}
                    </div>
                `;
            }).join('');
            
            alertsList.innerHTML = alertsHtml;
        }
        
        // Clear alerts
        async function clearAlerts() {
            try {
                await fetch('/api/health-alerts/clear', { method: 'POST' });
                document.getElementById('alertsList').innerHTML = '<p>No recent alerts</p>';
            } catch (error) {
                console.error('Failed to clear alerts:', error);
            }
        }
        
        // Initialize heap usage chart
        async function initializeHeapChart() {
            const ctx = document.getElementById('heapChart').getContext('2d');
            
            heapChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Heap Utilization %',
                        data: [],
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Metaspace Utilization %',
                        data: [],
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Old Gen Utilization %',
                        data: [],
                        borderColor: '#f59e0b',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'GC Overhead %',
                        data: [],
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            type: 'time',
                            time: {
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'MMM dd HH:mm'
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Memory Utilization %'
                            },
                            min: 0,
                            max: 100,
                            grid: {
                                drawOnChartArea: true,
                            },
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'GC Overhead %'
                            },
                            min: 0,
                            max: 20,
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const data = heapChart.data.datasets[0].rawData;
                                    if (data && data[dataIndex]) {
                                        const point = data[dataIndex];
                                        return [
                                            `Heap: ${point.heapUsedMB}/${point.heapTotalMB} MB (${point.heapUtilizationPercent}%)`,
                                            `Metaspace: ${point.metaspaceUsedMB}/${point.metaspaceCapacityMB} MB (${point.metaspaceUtilizationPercent}%)`,
                                            `Old Gen: ${point.oldGenUsedMB}/${point.oldGenCapacityMB} MB`,
                                            `Young Gen: ${point.youngGenUsedMB}/${point.youngGenCapacityMB} MB`,
                                            `GC Counts - Young: ${point.youngGcCount}, Full: ${point.fullGcCount}`,
                                            `GC Times - Young: ${point.youngGcTimeSec}s, Full: ${point.fullGcTimeSec}s`
                                        ];
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });
            
            // Load initial data
            await updateHeapChart();
        }
        
        // Update heap chart with new data
        async function updateHeapChart() {
            try {
                // Default to 24 hours of data since no time range selector exists
                const hoursBack = 24;
                
                // Use the enhanced heap-metrics-history endpoint
                const endpoint = '/api/neo4j-health/queries/heap-metrics-history';
                
                const response = await fetch(`${endpoint}?hours=${hoursBack}&maxPoints=200`);
                const result = await response.json();
                
                if (!result.success) {
                    console.error('Failed to fetch heap metrics:', result.error);
                    updateDataSourceIndicator('Error loading data', 'error');
                    return;
                }
                
                const data = result.data || [];
                const preservationStats = result.metadata?.preservationStats || null;
                
                // Update data source indicator
                updateDataSourceIndicator(data, preservationStats);
                
                if (data.length === 0) {
                    heapChart.data.labels = [];
                    heapChart.data.datasets[0].data = [];
                    heapChart.data.datasets[1].data = [];
                    heapChart.data.datasets[2].data = [];
                    heapChart.data.datasets[3].data = [];
                    heapChart.update();
                    return;
                }
                
                // Prepare chart data
                const labels = data.map(point => new Date(point.timestamp));
                const heapUtilization = data.map(point => point.heapUtilizationPercent);
                const metaspaceUtilization = data.map(point => point.metaspaceUtilizationPercent);
                const oldGenUtilization = data.map(point => {
                    return point.oldGenCapacityMB > 0 ? 
                        Math.round((point.oldGenUsedMB / point.oldGenCapacityMB) * 100) : 0;
                });
                const gcOverhead = data.map(point => point.gcOverheadPercent || point.gcTimePercent || 0);
                
                // Calculate dynamic Y-axis range for GC Overhead
                const maxGcOverhead = Math.max(...gcOverhead.filter(val => val > 0));
                const gcAxisMax = calculateGcAxisMax(maxGcOverhead);
                
                // Update GC Overhead axis dynamically
                heapChart.options.scales.y1.max = gcAxisMax;
                
                // Add warning annotation if GC overhead is critically high
                if (maxGcOverhead > 100) {
                    heapChart.options.scales.y1.title.text = `‚ö†Ô∏è GC Overhead % (Max: ${maxGcOverhead.toFixed(1)}%)`;
                    heapChart.options.scales.y1.title.color = '#ef4444';
                } else if (maxGcOverhead > 50) {
                    heapChart.options.scales.y1.title.text = `‚ö†Ô∏è GC Overhead % (Max: ${maxGcOverhead.toFixed(1)}%)`;
                    heapChart.options.scales.y1.title.color = '#f59e0b';
                } else {
                    heapChart.options.scales.y1.title.text = 'GC Overhead %';
                    heapChart.options.scales.y1.title.color = '#666';
                }
                
                // Store raw data for tooltips
                heapChart.data.datasets[0].rawData = data;
                
                // Update chart
                heapChart.data.labels = labels;
                heapChart.data.datasets[0].data = heapUtilization;
                heapChart.data.datasets[1].data = metaspaceUtilization;
                heapChart.data.datasets[2].data = oldGenUtilization;
                heapChart.data.datasets[3].data = gcOverhead;
                heapChart.update();
                
                console.log(`Updated heap chart with ${data.length} data points from combined data sources`);
                console.log(`GC Overhead range: 0% - ${maxGcOverhead.toFixed(1)}%, Y-axis max: ${gcAxisMax}`);
                
            } catch (error) {
                console.error('Error updating heap chart:', error);
                updateDataSourceIndicator('Network error', 'error');
            }
        }

        // Global variable to track current metric view
        let currentMetricView = 'overview';

        // Metric view switching functionality
        function switchMetricView(view) {
            currentMetricView = view;
            
            // Update button states
            document.querySelectorAll('.metric-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            
            // Update explanation content
            updateExplanationContent(view);
            
            // Update chart based on view
            updateChartForView(view);
        }

        // Update explanation content based on selected view
        function updateExplanationContent(view) {
            const explanationContent = document.getElementById('explanationContent');
            
            const explanations = {
                overview: {
                    title: 'üè† Overview - Neo4j Memory Health',
                    content: `
                        <p>This view shows the most critical memory metrics for Neo4j stability. Monitor these key indicators:</p>
                        <ul>
                            <li><strong>Heap Utilization:</strong> Should stay below 80% for optimal performance</li>
                            <li><strong>Metaspace Utilization:</strong> Critical when above 90% - can cause OutOfMemoryError</li>
                            <li><strong>Old Generation:</strong> High utilization indicates objects living too long</li>
                            <li><strong>GC Overhead:</strong> Time spent in garbage collection - should be under 10%</li>
                        </ul>
                        <div class="warning">‚ö†Ô∏è Watch for sustained high utilization across multiple metrics - this indicates memory pressure.</div>
                    `
                },
                heap: {
                    title: 'üß† Heap Memory Analysis',
                    content: `
                        <p>Java heap memory is where Neo4j stores objects during execution. The heap is divided into generations:</p>
                        <ul>
                            <li><strong>Young Generation (Eden + Survivor):</strong> New objects are created here</li>
                            <li><strong>Old Generation:</strong> Long-lived objects that survived multiple GC cycles</li>
                            <li><strong>Total Heap:</strong> Combined young + old generation memory</li>
                        </ul>
                        <div class="info">üí° Healthy heap utilization: 60-80%. Above 85% indicates memory pressure.</div>
                        <div class="critical">üö® Above 95%: Risk of OutOfMemoryError and application crashes.</div>
                    `
                },
                metaspace: {
                    title: 'üîß Metaspace Memory Management',
                    content: `
                        <p>Metaspace stores class metadata and is critical for Neo4j's operation with many loaded classes:</p>
                        <ul>
                            <li><strong>Class Definitions:</strong> Metadata for all loaded Java classes</li>
                            <li><strong>Method Information:</strong> Bytecode and method signatures</li>
                            <li><strong>Constant Pool:</strong> String literals and class constants</li>
                        </ul>
                        <div class="warning">‚ö†Ô∏è Your system shows ${Math.round((386833.0/390464.0)*100)}% utilization - monitor closely!</div>
                        <div class="critical">üö® Above 95%: Immediate risk of MetaspaceOOM - Neo4j will crash!</div>
                    `
                },
                compressed: {
                    title: '‚ö†Ô∏è Compressed Class Space - Critical Monitoring',
                    content: `
                        <p>Compressed Class Space is a subset of Metaspace with a fixed size limit. When full, it causes immediate crashes:</p>
                        <ul>
                            <li><strong>Class Pointers:</strong> Compressed references to class metadata</li>
                            <li><strong>Fixed Size:</strong> Cannot be expanded at runtime (typically ~55MB)</li>
                            <li><strong>Critical Resource:</strong> When full, causes instant OutOfMemoryError</li>
                        </ul>
                        <div class="critical">üö® Your system shows ~97% utilization - CRITICAL! This is the most dangerous metric to watch.</div>
                        <p><strong>Immediate Actions if >95%:</strong></p>
                        <ul>
                            <li>Restart Neo4j during low-traffic period</li>
                            <li>Review and reduce loaded plugins/extensions</li>
                            <li>Consider increasing -XX:CompressedClassSpaceSize</li>
                        </ul>
                    `
                },
                survivor: {
                    title: 'üîÑ Survivor Space Analysis',
                    content: `
                        <p>Survivor spaces (S0 and S1) are part of the young generation where objects survive initial garbage collection:</p>
                        <ul>
                            <li><strong>S0 and S1:</strong> Objects alternate between these spaces during minor GC</li>
                            <li><strong>Promotion Threshold:</strong> Objects surviving multiple cycles move to Old Gen</li>
                            <li><strong>GC Efficiency:</strong> Proper sizing reduces GC overhead</li>
                        </ul>
                        <div class="info">üí° Your system: S0=${Math.round(0/73728*100)}%, S1=${Math.round(73062.4/73728*100)}% - S1 is actively used.</div>
                        <div class="warning">‚ö†Ô∏è High survivor utilization (>80%) may indicate objects living longer than expected.</div>
                    `
                },
                gc: {
                    title: 'üóëÔ∏è Garbage Collection Performance',
                    content: `
                        <p>Garbage Collection removes unused objects and is critical for Neo4j performance:</p>
                        <ul>
                            <li><strong>Young GC:</strong> Frequent, fast cleanup of short-lived objects</li>
                            <li><strong>Full GC:</strong> Expensive cleanup of entire heap - should be rare</li>
                            <li><strong>G1 Concurrent:</strong> Background cleanup with minimal application pause</li>
                            <li><strong>GC Overhead:</strong> Percentage of time spent in garbage collection</li>
                        </ul>
                        <div class="info">üí° Healthy GC: <5% overhead, young GC every few seconds, full GC rarely.</div>
                        <div class="warning">‚ö†Ô∏è >10% GC overhead indicates memory pressure or tuning issues.</div>
                        <div class="critical">üö® >20% GC overhead: Application performance severely impacted!</div>
                    `
                }
            };

            const explanation = explanations[view];
            explanationContent.innerHTML = `
                <h4>${explanation.title}</h4>
                ${explanation.content}
            `;
        }

        // Update chart datasets based on selected view
        function updateChartForView(view) {
            if (!heapChart) return;

            // Get current data
            const rawData = heapChart.data.datasets[0].rawData;
            if (!rawData || rawData.length === 0) return;

            const labels = rawData.map(point => new Date(point.timestamp));

            // Define different dataset configurations for each view
            const viewConfigs = {
                overview: {
                    datasets: [
                        {
                            label: 'Heap Utilization %',
                            data: rawData.map(point => point.heapUtilizationPercent),
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Metaspace Utilization %',
                            data: rawData.map(point => point.metaspaceUtilizationPercent),
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Old Gen Utilization %',
                            data: rawData.map(point => point.oldGenCapacityMB > 0 ? 
                                Math.round((point.oldGenUsedMB / point.oldGenCapacityMB) * 100) : 0),
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'GC Overhead %',
                            data: rawData.map(point => point.gcOverheadPercent || 0),
                            borderColor: 'rgb(255, 206, 86)',
                            backgroundColor: 'rgba(255, 206, 86, 0.1)',
                            yAxisID: 'y1'
                        }
                    ]
                },
                heap: {
                    datasets: [
                        {
                            label: 'Total Heap Utilization %',
                            data: rawData.map(point => point.heapUtilizationPercent),
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Old Gen Utilization %',
                            data: rawData.map(point => point.oldGenCapacityMB > 0 ? 
                                Math.round((point.oldGenUsedMB / point.oldGenCapacityMB) * 100) : 0),
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Young Gen Utilization %',
                            data: rawData.map(point => point.youngGenCapacityMB > 0 ? 
                                Math.round((point.youngGenUsedMB / point.youngGenCapacityMB) * 100) : 0),
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            yAxisID: 'y'
                        }
                    ]
                },
                metaspace: {
                    datasets: [
                        {
                            label: 'Metaspace Utilization %',
                            data: rawData.map(point => point.metaspaceUtilizationPercent),
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            yAxisID: 'y'
                        }
                    ]
                },
                compressed: {
                    datasets: [
                        {
                            label: 'Compressed Class Utilization %',
                            data: rawData.map(point => point.compressedClassCapacityMB > 0 ? 
                                Math.round((point.compressedClassUsedMB / point.compressedClassCapacityMB) * 100) : 0),
                            borderColor: 'rgb(255, 0, 0)',
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            yAxisID: 'y'
                        }
                    ]
                },
                survivor: {
                    datasets: [
                        {
                            label: 'Total Survivor Utilization %',
                            data: rawData.map(point => point.survivorCapacityMB > 0 ? 
                                Math.round((point.survivorUsedMB / point.survivorCapacityMB) * 100) : 0),
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'S0 Utilization %',
                            data: rawData.map(point => point.s0CapacityMB > 0 ? 
                                Math.round((point.s0UsedMB / point.s0CapacityMB) * 100) : 0),
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'S1 Utilization %',
                            data: rawData.map(point => point.s1CapacityMB > 0 ? 
                                Math.round((point.s1UsedMB / point.s1CapacityMB) * 100) : 0),
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            yAxisID: 'y'
                        }
                    ]
                },
                gc: {
                    datasets: [
                        {
                            label: 'GC Overhead %',
                            data: rawData.map(point => point.gcOverheadPercent || 0),
                            borderColor: 'rgb(255, 206, 86)',
                            backgroundColor: 'rgba(255, 206, 86, 0.1)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Young GC Count (per hour)',
                            data: rawData.map(point => point.youngGcCount || 0),
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            yAxisID: 'y1'
                        }
                    ]
                }
            };

            const config = viewConfigs[view];
            if (config) {
                // Store raw data in first dataset
                config.datasets[0].rawData = rawData;
                
                // Update chart
                heapChart.data.labels = labels;
                heapChart.data.datasets = config.datasets;
                heapChart.update();
            }
        }
        
        // Calculate appropriate Y-axis maximum for GC Overhead based on data range
        function calculateGcAxisMax(maxValue) {
            if (maxValue <= 0) return 20; // Default range for normal conditions
            if (maxValue <= 20) return 25;
            if (maxValue <= 50) return 60;
            if (maxValue <= 100) return 120;
            if (maxValue <= 200) return 250;
            if (maxValue <= 500) return 600;
            if (maxValue <= 1000) return 1200;
            if (maxValue <= 2000) return 2500;
            
            // For extremely high values, round up to nearest 1000
            return Math.ceil(maxValue / 1000) * 1000 + 500;
        }
        
        // Update data source indicator
        function updateDataSourceIndicator(data, preservationStats) {
            const indicator = document.getElementById('dataSourceIndicator');
            
            if (data === 'Error loading data' || data === 'Network error') {
                indicator.innerHTML = `‚ö†Ô∏è ${data}`;
                indicator.style.color = '#ef4444';
                return;
            }
            
            const dataLength = Array.isArray(data) ? data.length : 0;
            
            // Count data sources
            const currentCount = data.filter(d => d.source === 'current').length;
            const preservedCount = data.filter(d => d.source === 'preserved').length;
            
            let statusText = `üìä Combined data (${dataLength} points)`;
            
            if (currentCount > 0 && preservedCount > 0) {
                statusText += ` - ${currentCount} current, ${preservedCount} preserved`;
                indicator.style.color = '#10b981'; // Green for combined data
            } else if (currentCount > 0) {
                statusText += ` - current data only`;
                indicator.style.color = '#3b82f6'; // Blue for current only
            } else if (preservedCount > 0) {
                statusText += ` - preserved data only`;
                indicator.style.color = '#f59e0b'; // Orange for preserved only
            } else {
                statusText = `üìä Data (${dataLength} points)`;
                indicator.style.color = '#6b7280'; // Gray for unknown source
            }
            
            if (preservationStats && preservationStats.preservedDataRange) {
                const oldestDate = new Date(preservationStats.preservedDataRange.oldest);
                statusText += ` (oldest: ${oldestDate.toLocaleDateString()})`;
            }
            
            indicator.innerHTML = statusText;
        }
        
        // Update time range
        async function updateTimeRange() {
            await updateHeapChart();
        }
        
        // Show error message
        function showError(message) {
            const alertsList = document.getElementById('alertsList');
            alertsList.innerHTML = `<div class="alert-item alert-critical">${message}</div>`;
        }

        // Initialize dashboard when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners to metric selector buttons
            document.querySelectorAll('.metric-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const view = this.getAttribute('data-view');
                    switchMetricView(view);
                });
            });

            // Initialize with overview view
            switchMetricView('overview');
            
            // Start data loading
            updateHeapChart();
            
            // Set up auto-refresh
            setInterval(updateHeapChart, 30000); // Refresh every 30 seconds
        });
    </script>
    </div>
</body>
</html>
